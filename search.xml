<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/11/11/food-trace/"/>
      <url>/2025/11/11/food-trace/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Fabric的高端食品安全系统"><a href="#基于Fabric的高端食品安全系统" class="headerlink" title="基于Fabric的高端食品安全系统"></a>基于Fabric的高端食品安全系统</h1><p><strong>项目介绍：</strong></p><p>构建一个食品溯源系统</p><p>核心目标：实现高端食品在生产、加工、物流、销售各个环节信息的上链与溯源。</p><p>具体任务：</p><p>(1) 搭建一个包含供应商、加工厂、物流商、零售商的多节点Fabric网络。</p><p>(2) 部署食品溯源链码，定义关键数据结构。</p><p>(3) 模拟各参与方依次调用链码，更新食品的状态。</p><p>(4) 实现一个面向消费者的溯源查询界面，通过扫描商品二维码，即可查看其完整的流转历史。</p><p><strong>项目环境：</strong></p><p>Ubuntu 24.04.1 LTS</p><p>Windows</p><p>Fabric 2.5.14</p><p>Fabric-ca 1.5.15</p><p>OpenJDK version “11.0.28”</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fabric环境搭建</title>
      <link href="/2025/11/09/Fabric/"/>
      <url>/2025/11/09/Fabric/</url>
      
        <content type="html"><![CDATA[<h1 id="Fabric环境搭建"><a href="#Fabric环境搭建" class="headerlink" title="Fabric环境搭建"></a>Fabric环境搭建</h1><p>本文将记录一下Fabric的环境搭建，操作环境Windows系统下的WSL2</p><h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><p>wsl(windows subsystem for linux)是windows系统下的linux子系统</p><p>wsl的安装很简单</p><p>首先以管理员身份运行cmd，输入第一条命令，把WSL的默认版本设成2</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version <span class="number">2</span></span><br></pre></td></tr></table></figure><p>之后执行第二条命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wsl --update --web-download</span><br><span class="line">#或者</span><br><span class="line">wsl --update</span><br><span class="line">#根据自己的网络环境选择，看看哪个下载的快</span><br></pre></td></tr></table></figure><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>只有WSL可不够，wsl就类似于vmware和virtualbox，还缺少一个应用内核，所以需要下载Ubuntu</p><p>下载也很简单，打开windows自带的Microsoft Store，搜索Ubuntu进行下载，推荐下载Ubuntu 24.04.1 LTS或Ubuntu 22.04.5 LTS</p><p>下载之后在开始界面搜索Ubuntu，打开并运行，第一次打开需要新建用户和创建密码，需要记住。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>首先进入Ubuntu，之后输入命令更新软件源列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure><p>下载git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install git</span><br></pre></td></tr></table></figure><p>安装curl,<code>curl</code> 是一个<strong>命令行工具</strong>，用于在网络上传输数据，支持 HTTP、HTTPS、FTP、SFTP 等多种协议，常被用来<strong>下载文件、测试 API、发送网络请求</strong>等，是开发者和系统管理员的常用工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install curl</span><br></pre></td></tr></table></figure><p>安装JQ，<code>jq</code> 是一个轻量级的命令行工具，专门用于处理 JSON 数据。它可以帮助你在终端中快速解析、过滤、转换和查询 JSON 格式的内容，是处理 JSON 数据的高效工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install jq</span><br></pre></td></tr></table></figure><p>安装Docker和Docker-Compose</p><p>Docker的安装可以选择安装在主机上，详细教程可以看我的上一篇博客<a href="https://hslslsl.github.io/2025/11/08/Docker/">Docker入门 | 流水博客</a></p><p>打开docker的设置，需要检查几个地方</p><ul><li>在“General”选项中，确保启用了“Use the WSL 2 based engine”选项。</li></ul><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/fabric1.png" alt="image-20251109154809174" style="zoom:50%;" /><ul><li>在“Resources” -&gt; “WSL Integration”选项中，确保Linux发行版已经被启用。</li></ul><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/fabric2.png" alt="image-20251109154956108" style="zoom:50%;" /><h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><p>在 Hyperledger Fabric 中，链码（智能合约）<strong>支持多种开发语言</strong>，包括 <strong>Go、Java、JavaScript&#x2F;TypeScript</strong> 等，可根据你的需求选择语言。本次采用Java语言进行开发</p><p>在 Ubuntu 中安装 <strong>Java 环境</strong> 和 <strong>构建工具（如 Maven）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装OpenJDK 11</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install openjdk-11-jdk -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">java -version  <span class="comment"># 应输出Java版本信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装maven</span></span><br><span class="line"><span class="built_in">sudo</span> apt install maven -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">mvn -version  <span class="comment"># 应输出Maven版本信息</span></span><br></pre></td></tr></table></figure><h2 id="下载fabric"><a href="#下载fabric" class="headerlink" title="下载fabric"></a>下载fabric</h2><p>步骤 1：在 WSL 的 Ubuntu 中创建统一的工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在用户主目录下创建主文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/hyperledger-fabric/&#123;fabric-samples,bin&#125;</span><br></pre></td></tr></table></figure><ul><li><code>~/hyperledger-fabric</code>：作为所有 Fabric 相关文件的根目录；</li><li><code>fabric-samples</code>：存放官方示例仓库（含测试网络、链码示例）；</li><li><code>bin</code>：存放 Fabric 二进制工具（<code>cryptogen</code>、<code>configtxgen</code>等）。</li></ul><p>步骤 2：克隆<code>fabric-samples</code>到指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/hyperledger-fabric</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hyperledger/fabric-samples.git</span><br></pre></td></tr></table></figure><p>步骤 3：下载二进制工具到<code>bin</code>目录</p><p>下载以下两个压缩包（国内可直接访问）：</p><ul><li><a href="https://github.com/hyperledger/fabric/releases/download/v2.5.0/hyperledger-fabric-linux-amd64-2.5.0.tar.gz">Fabric 2.5.0 二进制包</a></li><li><a href="https://github.com/hyperledger/fabric-ca/releases/download/v1.5.7/hyperledger-fabric-ca-linux-amd64-1.5.7.tar.gz">Fabric CA 1.5.7 二进制包</a></li></ul><p>步骤 4：将二进制包传输到 WSL 并解压</p><ol><li><p>将下载的两个压缩包复制到 WSL 的<code>~/hyperledger-fabric/bin</code>目录</p></li><li><p>在 WSL 终端中解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/hyperledger-fabric/bin</span><br><span class="line">tar -zxvf hyperledger-fabric-linux-amd64-2.5.0.tar.gz</span><br><span class="line">tar -zxvf hyperledger-fabric-ca-linux-amd64-1.5.7.tar.gz</span><br></pre></td></tr></table></figure></li></ol><p>步骤 5：配置环境变量（让工具全局可用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:~/hyperledger-fabric/bin&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>步骤 6：拉取 Fabric Docker 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/hyperledger-fabric/fabric-samples/test-network</span><br><span class="line">./network.sh pull</span><br></pre></td></tr></table></figure><p>步骤 7：验证安装（关键检查点）</p><p>（1）验证二进制工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cryptogen version  <span class="comment"># 应输出2.5.0</span></span><br><span class="line">peer version       <span class="comment"># 应输出2.5.0</span></span><br><span class="line">fabric-ca-client version  <span class="comment"># 应输出1.5.7</span></span><br></pre></td></tr></table></figure><p>（2）验证 Docker 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep hyperledger</span><br></pre></td></tr></table></figure><p>应看到<code>fabric-peer</code>、<code>fabric-orderer</code>、<code>fabric-ca</code>等镜像，版本为<code>2.5.0</code>或<code>1.5.7</code>。</p><p>但我升级到了最新版啊，二进制工具为2.5.14，fabric-ca为1.5.15</p><p>步骤 8：验证二进制工具版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cryptogen version  <span class="comment"># 应输出2.5.14</span></span><br><span class="line">peer version       <span class="comment"># 应输出2.5.14</span></span><br><span class="line">fabric-ca-client version  <span class="comment"># 应输出1.5.15</span></span><br></pre></td></tr></table></figure><p>步骤 9：启动测试网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/hyperledger-fabric/fabric-samples/test-network</span><br><span class="line">./network.sh up createChannel  <span class="comment"># 重启动并创建通道</span></span><br></pre></td></tr></table></figure><h2 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h2><h3 id="前期准备：Java代码"><a href="#前期准备：Java代码" class="headerlink" title="前期准备：Java代码"></a>前期准备：Java代码</h3><p>首先创建Maven项目，代码如下</p><p>FoodTraceChain.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.shim.ChaincodeBase;</span><br><span class="line"><span class="keyword">import</span> org.hyperledger.fabric.shim.ChaincodeStub;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodTraceChain</span> <span class="keyword">extends</span> <span class="title class_">ChaincodeBase</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">init</span><span class="params">(ChaincodeStub stub)</span> &#123;</span><br><span class="line">        <span class="comment">// 可进行初始化操作</span></span><br><span class="line">        <span class="keyword">return</span> newSuccessResponse(<span class="string">&quot;Init successful&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">invoke</span><span class="params">(ChaincodeStub stub)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fn</span> <span class="operator">=</span> stub.getFunction();</span><br><span class="line">        List&lt;String&gt; params = stub.getParameters();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (fn) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;addFood&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> addFood(stub, params);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;queryFood&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> queryFood(stub, params);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> newErrorResponse(<span class="string">&quot;Unknown function: &quot;</span> + fn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> newErrorResponse(<span class="string">&quot;Exception: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Response <span class="title function_">addFood</span><span class="params">(ChaincodeStub stub, List&lt;String&gt; params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (params.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newErrorResponse(<span class="string">&quot;addFood requires 3 args: id, name, producer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> params.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> params.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">producer</span> <span class="operator">=</span> params.get(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; food = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        food.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        food.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        food.put(<span class="string">&quot;producer&quot;</span>, producer);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(food);</span><br><span class="line">        stub.putStringState(id, json);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newSuccessResponse(Arrays.toString(<span class="string">&quot;OK&quot;</span>.getBytes()), json.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Response <span class="title function_">queryFood</span><span class="params">(ChaincodeStub stub, List&lt;String&gt; params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (params.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newErrorResponse(<span class="string">&quot;queryFood requires 1 arg: id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> params.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stub.getStringState(id);</span><br><span class="line">        <span class="keyword">if</span> (json == <span class="literal">null</span> || json.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> newSuccessResponse((<span class="string">&quot;NOT_FOUND:&quot;</span> + id).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newSuccessResponse(json.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FoodTraceChain</span>().start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>food-trace-chaincode<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fabric.chaincode.version</span>&gt;</span>2.5.7<span class="tag">&lt;/<span class="name">fabric.chaincode.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Java shim (可解析的 artifact，在 Maven Central 可用) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hyperledger.fabric-chaincode-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fabric-chaincode-shim<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;fabric.chaincode.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- JSON 序列化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>chaincode<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编译 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 打包成包含依赖的 fat-jar，方便 Java chaincode 容器使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">createDependencyReducedPom</span>&gt;</span>false<span class="tag">&lt;/<span class="name">createDependencyReducedPom</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.SF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.DSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.RSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.example.FoodTraceChain<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p><strong>总体目标</strong></p><ul><li>在 Windows 上编写并本地构建 Java 链码</li><li>在 WSL 的 Fabric 网络中打包、安装、审批、提交</li><li>在频道上调用与查询，完整跑通开发—部署—验证流程</li><li>使用 Java 容器模式（Peer 在 <code>fabric-javaenv</code> 容器里自动编译并运行）</li></ul><p><strong>项目准备（Windows）</strong></p><ul><li>代码关键点<ul><li>入口类：<code>g:\food-trace-test\chaincode\src\main\java\org\example\FoodTraceChain.java:72-74</code></li><li>写入：<code>g:\food-trace-test\chaincode\src\main\java\org\example\FoodTraceChain.java:41-58</code></li><li>查询：<code>g:\food-trace-test\chaincode\src\main\java\org\example\FoodTraceChain.java:60-69</code></li></ul></li><li>构建配置要点<ul><li><code>fabric-chaincode-shim</code> 版本使用 Maven Central 可用的 <code>2.5.7</code>：<code>g:\food-trace-test\chaincode\pom.xml:15</code></li><li>固定产物名为 <code>target/chaincode.jar</code>（容器构建脚本要求）：<code>g:\food-trace-test\chaincode\pom.xml:35</code></li><li>主类清单指向入口类：<code>g:\food-trace-test\chaincode\pom.xml:61</code>（<code>org.example.FoodTraceChain</code>）</li><li>Shade 过滤签名元数据，避免“Invalid signature file digest”错误：<code>g:\food-trace-test\chaincode\pom.xml:59-67</code>（排除 <code>META-INF/*.SF/*.DSA/*.RSA</code>）</li></ul></li><li>本地构建（可选但推荐）<ul><li><code>cd g:\food-trace-test\chaincode</code></li><li><code>mvn clean package -DskipTests</code></li><li>检查 <code>target/chaincode.jar</code> 存在，体积合理；确认清单含 <code>Main-Class</code></li></ul></li></ul><p><strong>WSL 准备</strong></p><ul><li>路径映射：<code>g:\food-trace-test\chaincode</code> 在 WSL 中是 <code>/mnt/g/food-trace-test/chaincode</code></li><li>导出配置路径（让 <code>peer</code> 找到 <code>core.yaml</code>）<ul><li><code>export FABRIC_CFG_PATH=/home/hsl/hyperledger-fabric/fabric-samples/config</code></li><li>验证：<code>ls $FABRIC_CFG_PATH/core.yaml</code></li></ul></li><li>导出 Orderer TLS 根证书（所有需要连 Orderer 的命令都要用）<ul><li><code>export ORDERER_CA=/home/hsl/hyperledger-fabric/fabric-samples/test-network/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</code></li></ul></li><li>切换组织环境（使用 <code>test-network</code> 的脚本）<ul><li><code>cd /home/hsl/hyperledger-fabric/fabric-samples/test-network &amp;&amp; . ./scripts/envVar.sh</code></li><li>Org1：<code>setGlobals 1</code>（检查 <code>echo $CORE_PEER_ADDRESS</code> 为 <code>localhost:7051</code>）</li><li>Org2：<code>setGlobals 2</code>（检查 <code>echo $CORE_PEER_ADDRESS</code> 为 <code>localhost:9051</code>）</li></ul></li></ul><p><strong>首次部署（Sequence&#x3D;1）</strong></p><ul><li>打包源码（生成链码包）：<ul><li><code>cd /mnt/g/food-trace-test/chaincode</code></li><li><code>peer lifecycle chaincode package foodtrace_1.0.tar.gz --path /mnt/g/food-trace-test/chaincode --lang java --label foodtrace_1.0</code></li></ul></li><li>安装到各 Peer：<ul><li>Org1：<code>setGlobals 1</code> → <code>peer lifecycle chaincode install /mnt/g/food-trace-test/chaincode/foodtrace_1.0.tar.gz</code></li><li>Org2：<code>setGlobals 2</code> → <code>peer lifecycle chaincode install /mnt/g/food-trace-test/chaincode/foodtrace_1.0.tar.gz</code></li></ul></li><li>查询并记录 <code>Package ID</code>：<ul><li>Org1&#x2F;Org2 分别执行：<code>peer lifecycle chaincode queryinstalled</code></li></ul></li><li>审批（两个组织都要）：<ul><li>Org1：<code>peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $ORDERER_CA --channelID mychannel --name foodtrace --version 1.0 --package-id &lt;PACKAGE_ID&gt; --sequence 1</code></li><li>Org2：同上</li></ul></li><li>提交定义：<ul><li><code>peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $ORDERER_CA --channelID mychannel --name foodtrace --version 1.0 --sequence 1 --peerAddresses localhost:7051 --tlsRootCertFiles /home/hsl/hyperledger-fabric/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles /home/hsl/hyperledger-fabric/fabric-samples/test-network/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</code></li></ul></li><li>验证提交：<ul><li><code>peer lifecycle chaincode querycommitted --channelID mychannel --name foodtrace</code></li></ul></li></ul><p><strong>后续升级（当代码或 POM 改动）</strong></p><ul><li>删除项目根的临时 <code>META-INF/</code>（若之前解压过 jar）：<code>rm -rf /mnt/g/food-trace-test/chaincode/META-INF</code></li><li>可选本地构建验证：<ul><li><code>cd /mnt/g/food-trace-test/chaincode &amp;&amp; mvn clean package -DskipTests &amp;&amp; ls target/chaincode.jar</code></li></ul></li><li>重新打包新标签：<ul><li><code>peer lifecycle chaincode package foodtrace_1.1.tar.gz --path /mnt/g/food-trace-test/chaincode --lang java --label foodtrace_1.1</code></li></ul></li><li>安装到 Org1&#x2F;Org2：<ul><li><code>peer lifecycle chaincode install /mnt/g/food-trace-test/chaincode/foodtrace_1.1.tar.gz</code></li></ul></li><li>查询新 <code>Package ID</code>：<code>peer lifecycle chaincode queryinstalled</code></li><li>审批并提交（sequence 递增）：<ul><li>Org1&#x2F;Org2 审批：<code>approveformyorg --version 1.1 --package-id &lt;新PACKAGE_ID&gt; --sequence 2</code></li><li>提交：<code>commit --version 1.1 --sequence 2</code>（同样带两个 <code>--peerAddresses</code> 与 <code>--tlsRootCertFiles</code>）</li></ul></li><li>验证提交：<code>querycommitted</code> 应显示 <code>Version: 1.1, Sequence: 2</code></li></ul><p><strong>调用与查询（满足背书策略）</strong></p><ul><li>写入（收集两个组织的背书）：<ul><li><code>peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile $ORDERER_CA -C mychannel -n foodtrace -c &#39;&#123;&quot;Args&quot;:[&quot;addFood&quot;,&quot;id1&quot;,&quot;Apple&quot;,&quot;FarmA&quot;]&#125;&#39; --peerAddresses localhost:7051 --tlsRootCertFiles /home/hsl/hyperledger-fabric/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles /home/hsl/hyperledger-fabric/fabric-samples/test-network/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt --waitForEvent</code></li></ul></li><li>查询：<ul><li><code>peer chaincode query -C mychannel -n foodtrace -c &#39;&#123;&quot;Args&quot;:[&quot;queryFood&quot;,&quot;id1&quot;]&#125;&#39;</code></li></ul></li></ul><p><strong>可选：简化调用（背书策略改为 OR）</strong></p><ul><li>如果想只连一个 Peer 就能成功，升级定义时加策略参数并递增 <code>sequence</code>：<ul><li>审批：<code>approveformyorg ... --sequence &lt;递增&gt; --signature-policy &quot;OR(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></li><li>提交：<code>commit ... --sequence &lt;递增&gt; --signature-policy &quot;OR(&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></li></ul></li></ul><p><strong>常见问题与排查</strong></p><ul><li><code>Config File &quot;core&quot; Not Found</code>：未设置 <code>FABRIC_CFG_PATH</code>，需指向包含 <code>core.yaml</code> 的目录（如 <code>fabric-samples/config</code>）</li><li><code>Invalid signature file digest</code>：胖包包含签名元数据，需在 Shade 里排除（见 <code>pom.xml:59-67</code>）</li><li><code>metadata file path must begin with META-INF/statedb</code>：项目根产生了 <code>META-INF/</code> 目录（例如解压清单），删除根目录的 <code>META-INF/</code></li><li>安装超时或 500：<ul><li>确保 Peer 容器运行；使用 <code>setGlobals</code> 切到正确组织；加 <code>--connTimeout 20s</code></li><li>预拉镜像：<code>docker pull hyperledger/fabric-javaenv:2.5</code></li></ul></li><li><code>chaincode registration failed: container exited with 1</code>：<ul><li>查看链码容器日志：<code>docker logs &lt;容器名&gt; --tail=200</code></li><li>检查 <code>Main-Class</code> 清单、胖包是否包含依赖、是否生成 <code>target/chaincode.jar</code></li></ul></li><li><code>ENDORSEMENT_POLICY_FAILURE</code>：<ul><li>写入时未满足背书策略；在 invoke 命令中同时连接两个 Peer，或变更签名策略为 OR</li></ul></li></ul><p><strong>为什么 shim 用 2.5.7</strong></p><ul><li><code>org.hyperledger.fabric-chaincode-java:fabric-chaincode-shim:2.5.14</code> 未发布到 Maven Central；<code>2.5.7</code> 是最新可用且兼容 Fabric 2.5.x 的版本</li><li>你网络的二进制版本与 Java shim 补丁号不需要完全一致，只要同属 2.5 主线即可</li></ul><p><strong>操作小清单（你可收藏）</strong></p><ul><li>设置配置与证书：<code>export FABRIC_CFG_PATH=...; export ORDERER_CA=...</code></li><li>打包源码：<code>peer lifecycle chaincode package &lt;label&gt;.tar.gz --path /mnt/g/... --lang java --label &lt;label&gt;</code></li><li>安装：<code>peer lifecycle chaincode install &lt;label&gt;.tar.gz</code></li><li>查询包：<code>peer lifecycle chaincode queryinstalled</code></li><li>审批：<code>peer lifecycle chaincode approveformyorg ... --package-id &lt;PKG_ID&gt; --sequence &lt;N&gt;</code></li><li>提交：<code>peer lifecycle chaincode commit ... --sequence &lt;N&gt;</code></li><li>查询定义：<code>peer lifecycle chaincode querycommitted --channelID mychannel --name foodtrace</code></li><li>调用（双背书）：<code>peer chaincode invoke ... --peerAddresses &lt;org1&gt; --tlsRootCertFiles &lt;org1crt&gt; --peerAddresses &lt;org2&gt; --tlsRootCertFiles &lt;org2crt&gt;</code></li><li>查询：<code>peer chaincode query -C mychannel -n foodtrace -c ...</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/2025/11/08/Docker/"/>
      <url>/2025/11/08/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><p>演示环境为Windows系统</p><h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><p>首先以管理员身份运行cmd，输入第一条命令，把WSL的默认版本设成2</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version <span class="number">2</span></span><br></pre></td></tr></table></figure><p>之后执行第二条命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wsl --update --web-download</span><br><span class="line">#或者</span><br><span class="line">wsl --update</span><br><span class="line">#根据自己的网络环境选择，看看哪个下载的快</span><br></pre></td></tr></table></figure><h2 id="下载并安装Docker"><a href="#下载并安装Docker" class="headerlink" title="下载并安装Docker"></a>下载并安装Docker</h2><p>打开<a href="https://www.docker.com/">docker官网</a>，找到适配自己系统的版本下载。</p><p>安装一路默认即可，但默认安装路径是在C:\Program Files\docker下，若要自定义安装路径需要使用命令行下载。</p><p>打开cmd，cd到docker安装包的目录下，输入以下命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Docker Desktop Installer.exe&quot; install --installation-<span class="built_in">dir</span>=安装路径 --windows-containers-default-data-root=windows容器路径 --wsl-default-data-root=wsl路径</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Docker Desktop Installer.exe&quot; install --installation-<span class="built_in">dir</span>=&quot;F:\Docker&quot; --windows-containers-default-data-root=&quot;F:\Docker\data&quot; --wsl-default-data-root=&quot;F:\Docker\wsl&quot;</span><br></pre></td></tr></table></figure><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p>虽然docker desktop提供了图形化界面，但还是有更多人愿意使用命令来操作，接下来介绍几个最重要的命令</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 仓库地址/命名空间(作者名)/镜像名:tag标签(版本号)</span><br></pre></td></tr></table></figure><p>下面认识一下docker的官方仓库<a href="https://hub.docker.com/">dockerhub</a></p><p>打开网站后可以直接搜索自己想要的镜像，里面也有详细的使用说明。</p><p>国内的网络使用pull命令可能会报错，这时候可以选择使用国内镜像站。</p><p>首先打开docker desktop的设置界面，找到docker engine</p><p>在false后面打上逗号，换行粘贴以下内容，之后点击右下角的应用并重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://docker.m.daocloud.io&quot;,</span><br><span class="line">    &quot;https://docker.1panel.live&quot;,</span><br><span class="line">    &quot;https://hub.rat.dev&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/docker1.png" alt="image-20251108164224663"></p><p>还有几个镜像相关的命令</p><ol><li><p><code>docker images</code>可以查看下载过的镜像</p></li><li><p><code>docker rmi 镜像名/镜像ID</code>可以删除已下载的镜像</p></li></ol><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>这是最最重要的命令了，这一步就是使用镜像创建一个容器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名</span><br></pre></td></tr></table></figure><p>成功跑起来之后可以使用以下命令来查看进程状态，ps就是process status的缩写</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>删除容器的命令是</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器ID</span><br></pre></td></tr></table></figure><p>类似的，有一个创建容器的命令，区别在于create之后不会立即启动，要启动还需要start命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create 镜像名</span><br></pre></td></tr></table></figure><h4 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h4><p>由于执行<code>docker run 镜像名</code>会占用一个命令行窗口，所以常使用启动参数<code>-d</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 镜像名</span><br></pre></td></tr></table></figure><p>-d是detached mode，就是分离模式，表示让容器在后台执行</p><p>截至目前，我们学习了docker pull来拉取镜像，也学了docker run来运行容器。但其实可以直接使用docker run，如果docker发现本地不存在run的镜像，则会自动拉取然后再创建并运行容器。</p><p>接下来是<code>-p 端口a:端口b</code></p><p>原因是，比如我们在主机上安装nginx，在浏览器输入localhost:80可以访问到nginx页面，但是如果是在docker容器内安装了nginx，在浏览器输入localhost:80则无法访问到nginx页面，所以此时需要添加一个启动参数<code>-p 80:80</code>，作用就在于给主机和容器创建一个映射，冒号前面是宿主机的端口，冒号后面是容器的端口。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">80</span>:<span class="number">80</span> 镜像名</span><br></pre></td></tr></table></figure><p>然后是<code>-v 目录a:目录b</code>，它的作用是把宿主机与容器的文件目录进行绑定，这样在容器内对这个文件夹的修改会影响宿主机的文件夹，反之亦然。而且在删除容器之后，数据文件依旧保持在宿主机的文件夹中，有持久化保存的作用，这个文件夹也被称为挂载卷。同样的，前一个目录是宿主机文件夹目录，后一个是容器文件夹目录</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">80</span>:<span class="number">80</span> -v 目录a:目录b 镜像名</span><br></pre></td></tr></table></figure><p>剩下的参数进行简单的罗列：</p><ol><li><code>-e</code>，用来往容器里面传递环境变量</li><li><code>--name</code>用来给容器自定义名字</li><li><code>-it</code>可以让我们控制台进入容器进行交互</li><li><code>--rm</code>指的是当容器停止的时候就把容器删除掉</li><li><code>--restart</code>用来配置容器在停止时的的重启策略，常用的有<code>--restart always</code>会在容器停止的时候立即重启，包括容器内崩溃或宿主机断电，同样还有<code>--restart unless-stopped</code>，意思是手动停止的话就不会重启了</li></ol><h4 id="容器停止和重启"><a href="#容器停止和重启" class="headerlink" title="容器停止和重启"></a>容器停止和重启</h4><p>要暂停容器直接执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID</span><br></pre></td></tr></table></figure><p>执行<code>docker ps -a</code>可以查看所有容器，包括停止了的容器，要再次启动容器则执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">start</span> 容器ID</span><br></pre></td></tr></table></figure><p>直接重启就好了，之前的参数会被保存下来不需要重新编辑，如果忘记了当时的启动参数是什么，可以执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hardhat 技术详解：合约编译、Mocha/Chai 测试、多网络部署与安全实践</title>
      <link href="/2025/10/26/hardhat/"/>
      <url>/2025/10/26/hardhat/</url>
      
        <content type="html"><![CDATA[<h1 id="Hardhat-技术详解：合约编译、Mocha-Chai-测试、多网络部署与安全实践"><a href="#Hardhat-技术详解：合约编译、Mocha-Chai-测试、多网络部署与安全实践" class="headerlink" title="Hardhat 技术详解：合约编译、Mocha&#x2F;Chai 测试、多网络部署与安全实践"></a>Hardhat 技术详解：合约编译、Mocha&#x2F;Chai 测试、多网络部署与安全实践</h1><p><strong>什么是 Hardhat？</strong></p><p>Hardhat 是一个专为 Ethereum 开发者设计的开发环境，主要用于编译、部署、测试和调试智能合约。它提供了一套完整的工具链，能够显著提升智能合约开发的效率和体验。</p><p><strong>Hardhat 的主要优势</strong></p><ol><li><strong>本地开发网络</strong>：内置 Hardhat Network，可快速启动本地测试网络，无需依赖外部服务</li><li><strong>强大的插件生态</strong>：支持通过插件扩展功能，如合约验证、Gas 分析等</li><li><strong>调试友好</strong>：提供详细的错误信息和调试工具，帮助开发者快速定位问题</li><li><strong>TypeScript 支持</strong>：原生支持 TypeScript，提升开发体验</li><li><strong>灵活的配置</strong>：通过 <code>hardhat.config.js</code> 文件轻松配置项目</li><li><strong>丰富的工具集</strong>：内置 Ethers.js 和 Waffle 等库，简化合约交互</li></ol><h2 id="创建及配置Hardhat项目"><a href="#创建及配置Hardhat项目" class="headerlink" title="创建及配置Hardhat项目"></a>创建及配置Hardhat项目</h2><p>Hardhat 构建在 Node.js 之上， 使用 Hardhat 要求我们在电脑先安装好Node.js (&gt;&#x3D; 16.0)， 环境准备可以参考<a href="https://learnblockchain.cn/docs/hardhat/tutorial/setting-up-the-environment.html">这里</a></p><p>首先创建项目目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> hardhat-tutorial</span><br><span class="line"><span class="built_in">cd</span> hardhat-tutorial</span><br></pre></td></tr></table></figure><p>初始化Node项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>接下来会出现一系列初始化配置提示（如项目名称、版本等），直接按回车使用默认值即可，最后输入yes确认配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm <span class="built_in">help</span> init` <span class="keyword">for</span> definitive documentation on these fields</span><br><span class="line">and exactly what they <span class="keyword">do</span>.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">save it as a dependency <span class="keyword">in</span> the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any <span class="keyword">time</span> to quit.</span><br><span class="line">package name: (hardhat-tutorial)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description:</span><br><span class="line">entry point: (index.js)</span><br><span class="line"><span class="built_in">test</span> <span class="built_in">command</span>:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to G:\WEB3\hardhat\hardhat-tutorial\package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;hardhat-tutorial&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this OK? (<span class="built_in">yes</span>) <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>安装 Hardhat ：</p><p><code>--save-dev</code>（简写<code>-D</code>）的作用是将安装的包作为<strong>开发依赖</strong>写入<code>package.json</code>的<code>devDependencies</code>字段中。</p><p>此时会默认安装最高版本Hardhat v3.0.9</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure><p>在安装<strong>Hardhat</strong>的目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat --init</span><br></pre></td></tr></table></figure><p>之后需要初始化一些项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; npx hardhat --init</span><br><span class="line"></span><br><span class="line">WARNING: You are using Node.js 18.17.1 <span class="built_in">which</span> is not supported by Hardhat.</span><br><span class="line">Please upgrade to 22.10.0 or a later LTS version (even major version number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> █████  █████                         ███  ███                  ███      ██████</span><br><span class="line">░░███  ░░███                         ░███ ░███                 ░███     ███░░███</span><br><span class="line"> ░███   ░███   ██████  ████████   ███████ ░███████    ██████  ███████  ░░░  ░███</span><br><span class="line"> ░██████████  ░░░░░███░░███░░███ ███░░███ ░███░░███  ░░░░░███░░░███░      ████░</span><br><span class="line"> ░███░░░░███   ███████ ░███ ░░░ ░███ ░███ ░███ ░███   ███████  ░███      ░░░░███</span><br><span class="line"> ░███   ░███  ███░░███ ░███     ░███ ░███ ░███ ░███  ███░░███  ░███ ███ ███ ░███</span><br><span class="line"> █████  █████░░███████ █████    ░░███████ ████ █████░░███████  ░░█████ ░░██████</span><br><span class="line">░░░░░  ░░░░░  ░░░░░░░ ░░░░░      ░░░░░░░ ░░░░ ░░░░░  ░░░░░░░    ░░░░░   ░░░░░░</span><br><span class="line"></span><br><span class="line">👷 Welcome to Hardhat v3.0.9 👷</span><br><span class="line"></span><br><span class="line">√ Which version of Hardhat would you like to use? · hardhat-2</span><br><span class="line">√ Where would you like to initialize the project?</span><br><span class="line"></span><br><span class="line">Please provide either a relative or an absolute path: · G:\WEB3\hardhat\hardhat-tutorial</span><br><span class="line">√ What <span class="built_in">type</span> of project would you like to initialize? · mocha-ethers-js</span><br></pre></td></tr></table></figure><p>不过截至2025年10月26日，Hardhat v3.0.9存在依赖冲突问题。若安装后出现异常，需先卸载已安装的Hardhat及初始化生成的文件，再指定稳定版本安装。</p><p>指定下载版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D hardhat@^2.26.0</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat</span><br></pre></td></tr></table></figure><p>之后需要初始化一些项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888</span><br><span class="line">888    888     <span class="string">&quot;88b 888P&quot;</span>  d88<span class="string">&quot; 888 888 &quot;</span>88b     <span class="string">&quot;88b 888</span></span><br><span class="line"><span class="string">888    888 .d888888 888    888  888 888  888 .d888888 888</span></span><br><span class="line"><span class="string">888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.</span></span><br><span class="line"><span class="string">888    888 &quot;</span>Y888888 888     <span class="string">&quot;Y88888 888  888 &quot;</span>Y888888  <span class="string">&quot;Y888</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Welcome to Hardhat v2.26.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">√ What do you want to do? · Create a JavaScript project</span></span><br><span class="line"><span class="string">√ Hardhat project root: · G:\WEB3\hardhat\hardhat-tutorial</span></span><br><span class="line"><span class="string">√ Do you want to add a .gitignore? (Y/n) · y</span></span><br><span class="line"><span class="string">√ Do you want to install this sample project&#x27;s dependencies with npm (@nomicfoundation/hardhat-toolbox)? (Y/n) · y</span></span><br></pre></td></tr></table></figure><p>创建好的 Hardhat 工程包含下列文件：</p><ul><li><code>contracts</code>：智能合约目录</li><li><code>scripts</code> ：部署脚本文件</li><li><code>test</code>：智能合约测试用例文件夹。</li><li><code>hardhat.config.js</code>：配置文件，配置hardhat连接的网络及编译选项。</li></ul><p>如果没有scripts&#x2F;可能是初始化有问题，自己手动新建文件夹scripts，再在scripts目录下新建文件<code>deploy.js</code></p><p>自动生成的 <code>deploy.js</code> 不是空白的，它会包含一个<strong>针对默认示例合约（<code>Lock.sol</code>）的部署脚本</strong>，内容是完整的部署逻辑。以下是典型的自动生成内容（基于 Hardhat JavaScript 模板）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hre = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 计算一个未来的时间（示例中是部署后60秒），作为Lock合约的解锁时间</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">ONE_YEAR_IN_SECS</span> = <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">const</span> unlockTime = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>) + <span class="variable constant_">ONE_YEAR_IN_SECS</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 部署时需要的初始资金（示例中是1 ETH，单位是wei）</span></span><br><span class="line">  <span class="keyword">const</span> lockedAmount = hre.<span class="property">ethers</span>.<span class="title function_">parseEther</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取Lock合约的工厂（用于部署）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Lock</span> = <span class="keyword">await</span> hre.<span class="property">ethers</span>.<span class="title function_">getContractFactory</span>(<span class="string">&quot;Lock&quot;</span>);</span><br><span class="line">  <span class="comment">// 部署合约，传入构造函数参数（unlockTime和接收的初始资金）</span></span><br><span class="line">  <span class="keyword">const</span> lock = <span class="keyword">await</span> <span class="title class_">Lock</span>.<span class="title function_">deploy</span>(unlockTime, &#123; <span class="attr">value</span>: lockedAmount &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待合约部署完成（上链确认）</span></span><br><span class="line">  <span class="keyword">await</span> lock.<span class="title function_">waitForDeployment</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印合约部署后的地址</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Lock with 1 ETH and unlock timestamp <span class="subst">$&#123;unlockTime&#125;</span> deployed to: <span class="subst">$&#123;<span class="keyword">await</span> lock.getAddress()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行main函数，并处理错误</span></span><br><span class="line"><span class="title function_">main</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  process.<span class="property">exitCode</span> = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="编写并编译合约"><a href="#编写并编译合约" class="headerlink" title="编写并编译合约"></a>编写并编译合约</h2><p>合约开发推荐使用 VSCode 编辑器，并搭配 Solidity 插件（如 Nomic Foundation 官方的 Solidity 插件），可获得语法高亮、编译报错提示、自动补全等功能，提升开发效率。在<code>contracts</code> 下新建一个合约文件 <code>Counter.sol</code> (<code>*.sol</code> 是 Solidity 合约文件的后缀名), 复制如下代码：</p><p>一个简单的计数器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Counter &#123;</span><br><span class="line">    uint counter;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        counter = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function count() public &#123;</span><br><span class="line">        counter = counter + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译合约</p><p>显示successfully为编译成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><p>成功编译后，会在 <code>artifacts/contracts/</code> 目录下生成<code>Counter.json</code> 和 build-info， <code>Counter.json</code>包含了智能合约的 ABI 、字节码（Bytecode）等。</p><h2 id="测试合约"><a href="#测试合约" class="headerlink" title="测试合约"></a>测试合约</h2><p>测试合约需要编写测试用例，为智能合约编写自动化测试至关重要，因为事关用户资金。</p><p>在我们的测试中，使用Harhdat内置的网络，使用ethers.js与前面的合约进行交互，并使用Mocha作为测试运行器。</p><p>在项目 <code>test</code>下，并创建一个名为<code>Counter.js</code>的新文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;Counter&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [owner, otherAccount] = <span class="keyword">await</span> ethers.<span class="title function_">getSigners</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Counter</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;Counter&quot;</span>);</span><br><span class="line">    <span class="comment">// 部署合约</span></span><br><span class="line">    counter = <span class="keyword">await</span> <span class="title class_">Counter</span>.<span class="title function_">deploy</span>();</span><br><span class="line">    <span class="comment">// Ethers v6 中用 waitForDeployment() 替代 deployed()，等待部署上链确认</span></span><br><span class="line">    <span class="keyword">await</span> counter.<span class="title function_">waitForDeployment</span>();</span><br><span class="line">    <span class="comment">// Ethers v6 中通过 getAddress() 方法获取合约地址（不再直接用 .address 属性）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;counter:&quot;</span> + <span class="keyword">await</span> counter.<span class="title function_">getAddress</span>());</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//确保测试用例执行前，合约已部署好</span></span><br><span class="line">  <span class="title function_">before</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">init</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个 “测试用例”</span></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;init equal 0&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> counter.<span class="title function_">get</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">it</span>(<span class="string">&quot;add 1 equal 1&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tx = <span class="keyword">await</span> counter.<span class="title function_">count</span>();</span><br><span class="line">    <span class="keyword">await</span> tx.<span class="title function_">wait</span>(); <span class="comment">// 等待交易上链确认，v6 中此写法不变</span></span><br><span class="line">    <span class="title function_">expect</span>(<span class="keyword">await</span> counter.<span class="title function_">get</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面结合代码解析智能合约测试的核心逻辑：</p><p>智能合约的测试代码通常基于 <strong>JavaScript（或 TypeScript）语法</strong> 编写，结合 <strong>Mocha 测试框架</strong>、<strong>Chai 断言库</strong>，以及 <strong>Hardhat + Ethers.js</strong> 来与合约交互。</p><p>Mocha 和 Chai 是测试中分工明确的两个工具：<strong>Mocha 负责 “组织测试逻辑”</strong>（比如哪些是测试组、先执行什么后执行什么），<strong>Chai 负责 “验证结果”</strong>（比如判断 “实际值是否等于预期值”）。</p><h3 id="Mocha：测试框架（负责-“组织测试”）"><a href="#Mocha：测试框架（负责-“组织测试”）" class="headerlink" title="Mocha：测试框架（负责 “组织测试”）"></a>Mocha：测试框架（负责 “组织测试”）</h3><p><strong>作用</strong></p><ul><li>定义测试的 “结构”（比如把测试分成组）。</li><li>控制测试的 “流程”（比如测试前先部署合约、每个用例前重置环境）。</li><li>运行测试并输出结果（比如 “2 个用例通过，1 个失败”）。</li></ul><p><strong>核心语法</strong></p><table><thead><tr><th>语法</th><th>作用</th><th>合约测试场景示例</th></tr></thead><tbody><tr><td><code>describe(名称, 函数)</code></td><td>定义<strong>测试套件</strong>，将相关测试用例分组（如 “Token 合约测试”“Counter 合约测试”）。</td><td><code>describe(&quot;Token&quot;, function () &#123; /* 所有Token相关测试用例 */ &#125;)</code></td></tr><tr><td><code>it(描述, 函数)</code></td><td>定义<strong>单个测试用例</strong>，验证一个具体功能（如 “验证初始余额”“验证转账失败”）。</td><td><code>it(&quot;should transfer tokens correctly&quot;, async function () &#123; /* 转账测试逻辑 */ &#125;)</code></td></tr><tr><td><code>before(函数)</code></td><td>生命周期钩子：<strong>整个测试套件执行前，只运行 1 次</strong>（如初始化全局变量）。</td><td><code>before(async () =&gt; &#123; /* 只部署1次合约，供所有用例使用 */ &#125;)</code></td></tr><tr><td><code>beforeEach(函数)</code></td><td>生命周期钩子：<strong>每个测试用例执行前，都运行 1 次</strong>（如重置合约、重新部署）。</td><td><code>beforeEach(async () =&gt; &#123; /* 每次测试前部署新合约，保证用例隔离 */ &#125;)</code></td></tr><tr><td><code>after(函数)</code></td><td>生命周期钩子：<strong>整个测试套件执行后，只运行 1 次</strong>（如清理测试数据）。</td><td><code>after(async () =&gt; &#123; /* 测试结束后销毁合约或释放资源 */ &#125;)</code></td></tr><tr><td><code>afterEach(函数)</code></td><td>生命周期钩子：<strong>每个测试用例执行后，都运行 1 次</strong>（如清空临时变量）。</td><td><code>afterEach(async () =&gt; &#123; /* 每次测试后重置账户余额 */ &#125;)</code></td></tr></tbody></table><h3 id="Chai：断言库（负责-“验证结果”）"><a href="#Chai：断言库（负责-“验证结果”）" class="headerlink" title="Chai：断言库（负责 “验证结果”）"></a>Chai：断言库（负责 “验证结果”）</h3><p><strong>作用</strong></p><ul><li>提供 “断言语法”，判断 “实际运行结果” 是否符合 “预期结果”。</li><li>若断言失败，Mocha 会标记该测试用例 “失败” 并显示错误信息。</li></ul><p><strong>核心语法（常用 BDD 风格 <code>expect</code>）</strong></p><p>Chai 最常用的是 <strong><code>expect</code> 风格</strong>，核心是 “<code>expect(实际值).断言方法(预期值)</code>”，以下是测试中最常用的断言语法：</p><table><thead><tr><th>断言语法</th><th>作用</th><th>合约测试场景示例</th></tr></thead><tbody><tr><td><code>expect(实际值).to.equal(预期值)</code></td><td>验证 “实际值” 与 “预期值” 严格相等（数字、地址等）。</td><td>验证初始余额：<code>expect(await token.balanceOf(owner)).to.equal(1000000)</code></td></tr><tr><td><code>expect(操作).to.be.reverted</code></td><td>验证 “某个操作会触发交易回滚”（不指定错误信息）。</td><td>验证无权限操作失败：<code>expect(token.connect(user1).mint(100)).to.be.reverted</code></td></tr><tr><td><code>expect(操作).to.be.revertedWith(错误信息)</code></td><td>验证 “回滚时的错误信息与预期一致”。</td><td>验证余额不足转账失败：<code>expect(token.transfer(addr1, 200)).to.be.revertedWith(&quot;ERC20: insufficient balance&quot;)</code></td></tr><tr><td><code>expect(实际值).to.be.gt(预期值)</code></td><td>验证 “实际值” 大于 “预期值”（gt &#x3D; greater than）。</td><td>验证转账后余额大于 0：<code>expect(await token.balanceOf(addr1)).to.be.gt(0)</code></td></tr><tr><td><code>expect(实际值).to.be.lt(预期值)</code></td><td>验证 “实际值” 小于 “预期值”（lt &#x3D; less than）。</td><td>验证转账后余额减少：<code>expect(await token.balanceOf(owner)).to.be.lt(1000000)</code></td></tr><tr><td><code>expect(实际值).to.be.an(&#39;类型&#39;)</code></td><td>验证 “实际值” 的类型（如 string、number）。</td><td>验证合约名称是字符串：<code>expect(await token.name()).to.be.an(&#39;string&#39;)</code></td></tr><tr><td><code>expect(实际值).to.include(目标值)</code></td><td>验证 “实际值” 包含 “目标值”（适用于数组、字符串）。</td><td>验证管理员列表包含地址：<code>expect(await token.admins()).to.include(owner.address)</code></td></tr></tbody></table><h3 id="总结：两者的配合"><a href="#总结：两者的配合" class="headerlink" title="总结：两者的配合"></a>总结：两者的配合</h3><p>简单总结两者的协作逻辑：</p><ul><li><strong>Mocha 搭架子</strong>：用 <code>describe</code> 分组、<code>it</code> 写用例、<code>beforeEach</code> 做准备，把测试逻辑 “串起来”。</li><li><strong>Chai 做验证</strong>：在每个 <code>it</code> 里用 <code>expect</code> 断言，判断合约运行结果是否符合预期。</li></ul><h3 id="Ethers-js"><a href="#Ethers-js" class="headerlink" title="Ethers.js"></a>Ethers.js</h3><p>重点我想说一下Ethers.js，Ethers.js 是 <strong>区块链交互的 “瑞士军刀”</strong>，需要处理从 “连接区块链”“签名交易” 到 “部署合约”“调用合约方法” 等全流程操作，所以方法多但分工明确。</p><p>这个测试文件里用了很多ethers.js方法，我挑其中一条来说一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;Counter&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>ethers.getContractFactory(&quot;Counter&quot;)</code>：Ethers.js 的方法，获取 “Counter 合约的工厂”（用于部署合约的工具）。</li><li><code>Counter</code>：变量名，存储合约工厂（后续用它部署合约）。</li></ul><p>这又引出了一个新的概念 <strong>“合约工厂”</strong> ，什么是合约工厂？可以理解为 <strong>“合约的模具”</strong>：</p><ul><li>当你写好一个 Solidity 合约（比如 <code>Counter.sol</code>），编译后会生成两个关键文件：<code>ABI</code>（合约接口描述，告诉外部 “这个合约有哪些方法”）和 <code>字节码</code>（合约的二进制代码，区块链上实际运行的内容）。</li><li>合约工厂（<code>ContractFactory</code>）就是 Ethers.js 中 “拿着 ABI 和字节码的工具”，用它可以 “生产”（部署）出具体的合约实例（<code>Contract</code>）。</li></ul><p>执行后 <code>Counter</code> 变量存储的是「Counter 合约的工厂实例」—— 它是 Ethers.js 中 <code>ContractFactory</code> 类的<strong>一个具体实例</strong>，专门用于部署 <code>Counter</code> 合约。<code>ContractFactory</code> 是 Ethers.js 内置的<strong>一个 JavaScript 类</strong>（不是 Solidity 合约），相当于 “合约部署工具的模板”，里面封装了部署合约的逻辑。</p><h4 id="ContractFactory-常用方法"><a href="#ContractFactory-常用方法" class="headerlink" title="ContractFactory 常用方法"></a><strong><code>ContractFactory</code> 常用方法</strong></h4><p>这些方法是「合约工厂实例」（比如你代码里的 <code>Counter</code> 变量）自带的，专门用于部署、关联合约：</p><table><thead><tr><th>方法名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>deploy(...)</code></td><td>部署合约到区块链，返回 “正在部署的合约实例”（需配合 <code>waitForDeployment</code> 确认）。</td><td><code>const counter = await Counter.deploy();</code>（部署 Counter 合约，无构造函数参数）</td></tr><tr><td><code>waitForDeployment()</code></td><td>等待合约部署完成（上链确认），Ethers v6 中需在 <code>deploy()</code> 后调用。</td><td><code>await counter.waitForDeployment();</code>（等 Counter 合约部署到链上）</td></tr><tr><td><code>attach(合约地址)</code></td><td>关联已部署的合约（不用重新部署，直接获取该地址的合约实例）。</td><td><code>const existingCounter = Counter.attach(&quot;0x123...&quot;);</code>（关联链上已有的 Counter 合约）</td></tr><tr><td><code>getDeployTransaction(...)</code></td><td>生成 “部署合约的交易对象”（仅生成，不发送，可用于手动签名）。</td><td><code>const tx = Counter.getDeployTransaction();</code>（生成部署交易，后续可手动用 Signer 发送）</td></tr><tr><td><code>connect(Signer)</code></td><td>切换部署合约的账户（默认用第一个测试账户，可指定其他账户部署）。</td><td><code>const counterByUser1 = Counter.connect(user1).deploy();</code>（用 user1 账户部署 Counter 合约）</td></tr></tbody></table><h4 id="Ethers-js-常用方法"><a href="#Ethers-js-常用方法" class="headerlink" title="Ethers.js 常用方法"></a><strong>Ethers.js 常用方法</strong></h4><p><strong>1. 测试环境 &#x2F; 账户相关（<code>ethers.xxx</code>）</strong></p><p>这些是直接通过 <code>ethers</code> 对象调用的方法，用于获取测试账户、连接网络：</p><table><thead><tr><th>方法名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>getSigners()</code></td><td>获取 Hardhat 本地测试网的所有测试账户（返回 Signer 数组）。</td><td><code>const [owner, otherAccount] = await ethers.getSigners();</code>（获取部署者、其他用户账户）</td></tr><tr><td><code>getContractFactory(合约名)</code></td><td>创建指定合约的工厂实例（<code>ContractFactory</code> 实例），用于部署合约。</td><td><code>const Counter = await ethers.getContractFactory(&quot;Counter&quot;);</code>（创建 Counter 合约工厂）</td></tr><tr><td><code>provider</code></td><td>获取当前连接的区块链 Provider（用于读链，如查余额、查区块）。</td><td><code>const balance = await ethers.provider.getBalance(owner.address);</code>（查 owner 账户余额）</td></tr></tbody></table><p><strong>2. 合约实例相关（<code>contract.xxx</code>，如你的 <code>counter</code> 变量）</strong></p><p>部署后得到的合约实例（如 <code>counter</code>），可调用合约自定义方法（如 <code>get()</code>、<code>count()</code>）和内置方法：</p><table><thead><tr><th>方法名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>getAddress()</code></td><td>获取合约在链上的地址（Ethers v6 中替代原 <code>contract.address</code> 属性）。</td><td><code>console.log(await counter.getAddress());</code>（打印 Counter 合约地址）</td></tr><tr><td><code>connect(Signer)</code></td><td>切换调用合约方法的账户（比如用 otherAccount 调用 counter 的方法）。</td><td><code>await counter.connect(otherAccount).count();</code>（用 otherAccount 触发计数 + 1）</td></tr><tr><td>合约自定义方法</td><td>调用你 Solidity 合约中写的方法（如 <code>get()</code>、<code>count()</code>、<code>transfer()</code>）。</td><td><code>await counter.get();</code>（调用 Counter 合约的 get 方法，查当前计数）</td></tr></tbody></table><p><strong>3. 交易相关（<code>tx.xxx</code>，如你的 <code>tx</code> 变量）</strong></p><p>调用合约 “写方法”（如 <code>count()</code>，会修改链上状态）时，会返回交易对象（<code>tx</code>），常用其方法：</p><table><thead><tr><th>方法名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>wait(确认数)</code></td><td>等待交易上链确认（默认 1 个确认），确认后才算交易完成。</td><td><code>let tx = await counter.count(); await tx.wait();</code>（等计数 + 1 的交易上链）</td></tr><tr><td><code>hash</code></td><td>获取交易哈希（可用于在区块链浏览器上查询交易详情）。</td><td><code>console.log(&quot;交易哈希：&quot;, tx.hash);</code>（打印计数 + 1 的交易哈希）</td></tr></tbody></table><p><strong>4. 按模块划分</strong></p><table><thead><tr><th>模块 &#x2F; 对象</th><th>作用</th><th>核心方法（举例）</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>连接区块链（读链）</td><td><code>getBalance()</code>（查余额）、<code>getBlock()</code>（查区块）、<code>getTransaction()</code>（查交易）</td></tr><tr><td><code>Signer</code></td><td>管理账户（签名、发交易）</td><td><code>signMessage()</code>（签名消息）、<code>sendTransaction()</code>（发交易）、<code>getAddress()</code>（查地址）</td></tr><tr><td><code>ContractFactory</code></td><td>部署合约（生产合约实例）</td><td><code>deploy()</code>（部署合约）、<code>attach()</code>（关联已部署合约）</td></tr><tr><td><code>Contract</code></td><td>已部署的合约实例（交互）</td><td>合约里的自定义方法（如 <code>get()</code>、<code>count()</code>）、<code>address</code>（合约地址）</td></tr><tr><td>工具函数</td><td>格式转换、单位换算等</td><td><code>parseEther()</code>（ETH 转 wei）、<code>formatEther()</code>（wei 转 ETH）、<code>getSigners()</code>（获取测试账户）</td></tr></tbody></table><p>附上<a href="https://docs.ethers.org/v6/">官方文档</a></p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>在终端上运行<code>npx hardhat test</code>。 你应该看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Counter</span><br><span class="line">counter:0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br><span class="line">    √ init equal 0</span><br><span class="line">    √ add 1 equal 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  2 passing (61ms)</span><br></pre></td></tr></table></figure><p>这意味着测试通过了</p><h2 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h2><p>部署合约我们需要编写一个部署脚本。在<code>scripts</code>文件夹，新建或找到<code>deploy.js</code> 用来写部署脚本，部署脚本其实和前面测试时 <code>init</code> 函数类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Counter</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;Counter&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> counter = <span class="keyword">await</span> <span class="title class_">Counter</span>.<span class="title function_">deploy</span>();</span><br><span class="line">    <span class="comment">// 用 waitForDeployment() 等待部署确认</span></span><br><span class="line">    <span class="keyword">await</span> counter.<span class="title function_">waitForDeployment</span>();</span><br><span class="line">    <span class="comment">// 用 getAddress() 获取合约地址</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Counter address:&quot;</span>, <span class="keyword">await</span> counter.<span class="title function_">getAddress</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><p>运行 <code>npx hardhat run scripts/deploy.js</code> 时，合约会部署到 Hardhat 内置网络上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G:\WEB3\hardhat\hardhat-tutorial&gt;npx hardhat run scripts/deploy.js</span><br><span class="line">Counter address: 0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br></pre></td></tr></table></figure><p>为了在运行任何任务时指示<strong>Hardhat</strong>连接到特定的EVM网络，可以使用<code>--network</code>参数。 像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network &lt;network-name&gt;</span><br></pre></td></tr></table></figure><p><code>network-name</code> 需要在 <code>hardhat.config.js</code> 文件中进行配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@type</span> import(&#x27;hardhat/config&#x27;).HardhatUserConfig */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.28&quot;</span>,</span><br><span class="line">  <span class="comment">// 配置网络</span></span><br><span class="line">  <span class="attr">networks</span>: &#123;</span><br><span class="line">      <span class="attr">hardhat</span>: &#123;&#125;, <span class="comment">// 本地 Hardhat Network</span></span><br><span class="line">      <span class="attr">sepolia</span>: &#123;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;https://sepolia.infura.io/v3/YOUR_INFURA_KEY&quot;</span>,</span><br><span class="line">        <span class="attr">accounts</span>:[<span class="string">&quot;YOUR_PRIVATE_KEY&quot;</span>],</span><br><span class="line">        <span class="attr">chainId</span>: <span class="number">11155111</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><p>在 Hardhat 开发中，借助第三方插件可进一步提升效率。以下是常用工具，涵盖<strong>测试、部署、验证、性能分析</strong>等场景，附带作用说明和代码样例：</p><ol><li><code>@nomicfoundation/hardhat-toolbox</code>（集成工具包）</li></ol><ul><li><p><strong>作用</strong>：一站式集成多个核心工具（<code>hardhat-ethers</code>、<code>hardhat-chai-matchers</code>、<code>solidity-coverage</code> 等），简化配置。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-toolbox</span><br></pre></td></tr></table></figure><p>配置<code>hardhat.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-toolbox&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">solidity</span>: <span class="string">&quot;0.8.24&quot;</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><code>@nomicfoundation/hardhat-verify</code>（合约验证）</li></ol><ul><li><p><strong>作用</strong>：将部署的合约自动提交到区块链浏览器（如 Etherscan）验证，方便用户查看合约源码。</p></li><li><p><strong>用法</strong>：</p><p>安装并配置 API 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-verify</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@nomicfoundation/hardhat-verify&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">networks</span>: &#123; <span class="attr">sepolia</span>: &#123; <span class="attr">url</span>: <span class="string">&quot;https://sepolia.infura.io/v3/...&quot;</span>, <span class="attr">accounts</span>: [...] &#125; &#125;,</span><br><span class="line">  <span class="attr">etherscan</span>: &#123; <span class="attr">apiKey</span>: <span class="string">&quot;你的Etherscan API密钥&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>部署后验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat verify --network sepolia 0xYourContractAddress</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><code>hardhat-deploy</code>（高级部署管理）</li></ol><ul><li><p><strong>作用</strong>：支持部署脚本的版本控制、多网络部署、依赖管理（如合约间依赖）。</p></li><li><p><strong>用法</strong>：</p><p>安装并创建部署脚本（<code>deploy/01_deploy_counter.js</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev hardhat-deploy</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deploy/01_deploy_counter.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">async</span> (&#123; getNamedAccounts, deployments &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deploy &#125; = deployments;</span><br><span class="line">  <span class="keyword">const</span> &#123; deployer &#125; = <span class="keyword">await</span> <span class="title function_">getNamedAccounts</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">deploy</span>(<span class="string">&quot;Counter&quot;</span>, &#123; <span class="attr">from</span>: deployer, <span class="attr">log</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">tags</span> = [<span class="string">&quot;Counter&quot;</span>];</span><br></pre></td></tr></table></figure><p>配置<code>hardhat.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-deploy&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">solidity</span>: <span class="string">&quot;0.8.24&quot;</span>,</span><br><span class="line">  <span class="attr">namedAccounts</span>: &#123; <span class="attr">deployer</span>: &#123; <span class="attr">default</span>: <span class="number">0</span> &#125; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat deploy --network sepolia</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><code>solidity-coverage</code>（测试覆盖率分析）</li></ol><ul><li><p><strong>作用</strong>：分析智能合约测试的代码覆盖率，帮助发现未测试的逻辑分支。</p></li><li><p><strong>用法</strong>：</p><p>安装并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev solidity-coverage</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat coverage</span><br></pre></td></tr></table></figure><p>执行后会生成<code>coverage</code>目录，包含 HTML 报告，可在浏览器中打开查看详细覆盖率。</p></li></ul><ol start="5"><li><code>hardhat-gas-reporter</code>（Gas 消耗分析）</li></ol><ul><li><p><strong>作用</strong>：测试时自动生成合约方法的 Gas 消耗报告，优化合约性能。</p></li><li><p><strong>用法</strong>：</p><p>安装并配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev hardhat-gas-reporter</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;hardhat-gas-reporter&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">gasReporter</span>: &#123; <span class="attr">enabled</span>: <span class="literal">true</span>, <span class="attr">currency</span>: <span class="string">&quot;USD&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行测试时自动输出报告：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li><code>typechain</code> + <code>@typechain/hardhat</code>（TypeScript 类型支持）</li></ol><ul><li><p><strong>作用</strong>：为 Solidity 合约生成 TypeScript 类型定义，提升开发体验（如自动补全、类型检查）。</p></li><li><p><strong>用法</strong>：</p><p>安装并配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typechain @typechain/hardhat @typechain/ethers-v6</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@typechain/hardhat&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; <span class="attr">solidity</span>: <span class="string">&quot;0.8.24&quot;</span>, <span class="attr">typechain</span>: &#123; <span class="attr">outDir</span>: <span class="string">&quot;typechain&quot;</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>编译合约后自动生成类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><p>生成的<code>typechain</code>目录可在 TypeScript 测试 &#x2F; 脚本中直接导入使用。</p></li></ul><h2 id="OpenZeppelin"><a href="#OpenZeppelin" class="headerlink" title="OpenZeppelin"></a>OpenZeppelin</h2><p><strong>OpenZeppelin 是什么？</strong></p><p>它是一个<strong>开源的智能合约库</strong>，提供经过审计、安全的合约模板（如 ERC20、ERC721、访问控制、升级合约等），以及工具（如合约验证、安全扫描）。核心价值是<strong>避免重复造轮子</strong>，同时保证合约的安全性（比如防止重入攻击、溢出漏洞等）。</p><p><strong>作用与场景</strong></p><ul><li><strong>标准化合约实现</strong>：直接继承 OpenZeppelin 的合约（如 <code>ERC20</code>、<code>ERC721</code>、<code>Ownable</code>），快速实现代币、NFT、权限控制等功能。</li><li><strong>安全工具</strong>：通过 <code>OpenZeppelin CLI</code> 或 <code>hardhat-upgrades</code> 插件，支持合约升级、安全审计等。</li></ul><p><strong>在 Hardhat 中使用的代码样例</strong></p><p>以 “创建一个基于 OpenZeppelin 的 ERC20 代币” 为例：</p><p><strong>1. 安装 OpenZeppelin 合约库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure><p><strong>2. 编写智能合约（继承 OpenZeppelin 的 ERC20）</strong></p><p>在 <code>contracts/MyToken.sol</code> 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.24;</span><br><span class="line"></span><br><span class="line">// 导入 OpenZeppelin 的 ERC20 合约</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 继承 ERC20，实现自己的代币</span><br><span class="line">contract MyToken is ERC20 &#123;</span><br><span class="line">    // 构造函数：调用 ERC20 的构造函数，设置名称和符号</span><br><span class="line">    constructor() ERC20(&quot;MyTestToken&quot;, &quot;MTT&quot;) &#123;</span><br><span class="line">        //  mint 100 万个代币给部署者</span><br><span class="line">        _mint(msg.sender, 1000000 * 10**decimals());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 部署与测试（结合 Hardhat）</strong></p><p>在 <code>scripts/deploy.js</code> 中部署该代币：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">MyToken</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;MyToken&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> myToken = <span class="keyword">await</span> <span class="title class_">MyToken</span>.<span class="title function_">deploy</span>();</span><br><span class="line">  <span class="keyword">await</span> myToken.<span class="title function_">waitForDeployment</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyToken deployed to:&quot;</span>, <span class="keyword">await</span> myToken.<span class="title function_">getAddress</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network sepolia</span><br></pre></td></tr></table></figure><p><strong>其他常用场景示例</strong></p><p><strong>1. 带权限控制的合约（继承 <code>Ownable</code>）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MySecureContract is Ownable &#123;</span><br><span class="line">    function restrictedFunction() external onlyOwner &#123;</span><br><span class="line">        // 只有合约所有者能调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 可升级合约（结合 <code>hardhat-upgrades</code> 插件）</strong></p><p>安装插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @openzeppelin/hardhat-upgrades</span><br></pre></td></tr></table></figure><p>配置 <code>hardhat.config.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@openzeppelin/hardhat-upgrades&quot;</span>);</span><br></pre></td></tr></table></figure><p>部署可升级合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers, upgrades &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">MyUpgradeableToken</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;MyToken&quot;</span>);</span><br><span class="line">  <span class="comment">// 部署可升级合约</span></span><br><span class="line">  <span class="keyword">const</span> myToken = <span class="keyword">await</span> upgrades.<span class="title function_">deployProxy</span>(<span class="title class_">MyUpgradeableToken</span>, []);</span><br><span class="line">  <span class="keyword">await</span> myToken.<span class="title function_">waitForDeployment</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Upgradeable Token deployed to:&quot;</span>, <span class="keyword">await</span> myToken.<span class="title function_">getAddress</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>一、核心技术定位与架构</strong></p><p>Hardhat 是基于 Node.js 的以太坊智能合约开发环境，核心架构围绕「任务系统」和「插件生态」设计：</p><ul><li><strong>任务系统</strong>：将开发流程（编译、测试、部署等）抽象为可扩展的任务（如 <code>hardhat compile</code>、<code>hardhat test</code>），支持自定义任务逻辑。</li><li><strong>插件生态</strong>：通过插件扩展核心能力（如合约验证、Gas 分析、类型生成），默认集成 Ethers.js 作为区块链交互层，与 Solidity 编译器深度联动。</li></ul><p><strong>二、开发环境核心组件与技术细节</strong></p><ol><li><strong>项目初始化与依赖管理</strong><ul><li>通过 <code>npx hardhat init</code> 生成标准化项目结构（<code>contracts/</code>、<code>scripts/</code>、<code>test/</code>、<code>hardhat.config.js</code>），依赖管理基于 <code>npm</code>，需注意版本兼容性（如 Ethers.js v6 对 <code>deployed()</code> 等方法的废弃）。</li><li>核心配置文件 <code>hardhat.config.js</code> 定义 Solidity 编译器版本、网络参数（RPC 节点、账户私钥）、插件引入等，是连接工具链的核心枢纽。</li></ul></li><li><strong>合约编译机制</strong><ul><li>执行 <code>npx hardhat compile</code> 时，Solidity 编译器将 <code>.sol</code> 合约编译为 <strong>ABI</strong>（应用二进制接口，描述合约方法和事件）和 <strong>字节码</strong>（链上执行的二进制指令），输出至 <code>artifacts/</code> 目录。</li><li>编译缓存（<code>cache/</code> 目录）通过哈希校验避免重复编译未修改的合约，提升效率。</li></ul></li></ol><p><strong>三、测试体系技术栈与逻辑</strong></p><p>测试核心依赖「Mocha（测试框架）+ Chai（断言库）+ Ethers.js（链交互）」的协同：</p><ul><li><strong>Mocha</strong>：通过 <code>describe</code>（测试套件）、<code>it</code>（测试用例）、<code>beforeEach</code>（前置钩子）组织测试结构，控制异步流程（支持 <code>async/await</code> 处理链上操作）。</li><li><strong>Chai</strong>：提供 <code>expect</code> 风格断言，结合 <code>@nomicfoundation/hardhat-chai-matchers</code> 扩展区块链专属断言（如 <code>to.be.revertedWith</code> 验证交易回滚）。</li><li><strong>Ethers.js</strong> 交互层：<ul><li>用 <code>ethers.getSigners()</code> 获取测试账户（<code>Signer</code> 实例，模拟链上用户）。</li><li>用 <code>ethers.getContractFactory()</code> 创建 <code>ContractFactory</code> 实例（绑定合约 ABI 和字节码，用于部署）。</li><li>部署后通过合约实例调用方法（如 <code>counter.get()</code>），并通过 <code>waitForDeployment()</code>（合约部署确认）、<code>tx.wait()</code>（交易上链确认）处理异步结果。</li></ul></li></ul><p><strong>四、部署流程技术要点</strong></p><ol><li><strong>合约部署逻辑</strong>：<ul><li>基于 <code>ContractFactory.deploy()</code> 发起部署交易（本质是向链上发送包含字节码的交易，<code>to</code> 字段为空）。</li><li>需通过 <code>waitForDeployment()</code> 等待区块确认，再通过 <code>getAddress()</code> 获取合约地址（Ethers.js v6 异步获取逻辑）。</li></ul></li><li><strong>多网络部署配置</strong>：<ul><li>在 <code>hardhat.config.js</code> 中配置网络参数（如 Sepolia 测试网），需指定第三方 RPC 节点 URL（Infura&#x2F;Alchemy 提供，含项目 ID）和部署账户私钥（建议通过 <code>dotenv</code> 环境变量管理，避免硬编码）。</li></ul></li></ol><p><strong>五、工具链扩展与安全实践</strong></p><ol><li><strong>关键插件技术作用</strong>：<ul><li><code>@nomicfoundation/hardhat-verify</code>：通过 Etherscan API 自动验证合约源码，需配置 API 密钥实现链上源码关联。</li><li><code>hardhat-deploy</code>：支持部署脚本版本控制、多网络状态管理，通过 <code>deployments</code> 对象实现合约依赖管理。</li><li><code>solidity-coverage</code>：通过插桩技术分析测试覆盖率，生成 HTML 报告定位未覆盖代码分支。</li><li><code>@openzeppelin/hardhat-upgrades</code>：结合 OpenZeppelin 库实现合约可升级（基于代理模式，分离逻辑与存储）。</li></ul></li><li><strong>安全开发核心工具</strong>：<ul><li>OpenZeppelin 合约库：提供经审计的标准化合约（<code>ERC20</code>、<code>Ownable</code> 等），封装安全逻辑（如防溢出、重入保护），通过继承复用避免重复开发风险。</li></ul></li></ol><p><strong>六、技术栈协同核心逻辑</strong></p><p>Hardhat 作为枢纽，串联起「Solidity 合约开发 → Ethers.js 链交互 → Mocha&#x2F;Chai 测试验证 → 插件扩展功能 → 多网络部署」全流程，其核心优势在于：</p><ul><li>对异步链上操作的原生支持（<code>async/await</code> 无缝衔接）。</li><li>插件化设计允许按需集成工具（测试、验证、性能分析等），保持核心轻量化。</li><li>与 Ethers.js、OpenZeppelin 等生态工具的深度联动，降低区块链开发的技术门槛。</li></ul><p>通过这套技术栈，开发者可高效完成从合约编写到上线的全链路开发，并通过标准化工具链保障代码安全性和可维护性。</p><p>注：学习自<a href="https://decert.me/tutorial/solidity/tools/hardhat#%E4%BD%BF%E7%94%A8openzepplin-%E7%AD%89%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93">Hardhat 开发框架 | Decert.me</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardhat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链的第一个应用：物品销售与全链路溯源合约解析</title>
      <link href="/2025/10/23/solidityFirstApp/"/>
      <url>/2025/10/23/solidityFirstApp/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链的第一个应用：物品销售与全链路溯源合约解析"><a href="#区块链的第一个应用：物品销售与全链路溯源合约解析" class="headerlink" title="区块链的第一个应用：物品销售与全链路溯源合约解析"></a>区块链的第一个应用：物品销售与全链路溯源合约解析</h1><p>在传统物品流通领域，溯源一直是行业痛点 —— 商品从生产到销售的全链路信息分散在不同主体手中，易被篡改、难以追溯，导致假货横行、质量纠纷频发。而区块链的<strong>去中心化、不可篡改、可追溯</strong>特性，恰好能解决这一问题：将商品的生产、分销、购买等全环节信息上链，形成不可篡改的 “数字身份证”，让每个参与者都能查询真实的流转记录。</p><p>本文将详细拆解一个基于 Solidity 的区块链合约，带你实现物品的 “添加 - 查询 - 溯源” 全流程功能，并优化权限控制（仅补充权限逻辑，不修改原有功能代码），确保流转信息的真实性与安全性。</p><h2 id="1-物品的添加和查询"><a href="#1-物品的添加和查询" class="headerlink" title="1. 物品的添加和查询"></a>1. 物品的添加和查询</h2><p>要实现物品溯源，首先需要为商品建立唯一的 “数字档案”—— 记录商品的基础信息（名称、质量、生产商等），并通过合约实现信息的添加与查询。这部分是整个溯源体系的 “地基”，确保每个商品都有可追溯的初始信息。</p><h3 id="1-1-定义结构体"><a href="#1-1-定义结构体" class="headerlink" title="1.1 定义结构体"></a>1.1 定义结构体</h3><p>商品的基础信息需要结构化存储，因此我们先定义Good结构体，涵盖商品从生产到流转的核心属性。每个字段的设计都对应实际业务需求，缺一不可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Good&#123;</span><br><span class="line">    string name;</span><br><span class="line">    string currentTraceName; //当前流转阶段名称</span><br><span class="line">    uint8 quality; //综合评分1-10</span><br><span class="line">    uint8 status; //物品状态 0=生产；1=分销； 2=购买</span><br><span class="line">    address producer;</span><br><span class="line">    bool exists;//物品存在标志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要这样设计？</strong></p><ul><li><p>status字段是关键：通过 0&#x2F;1&#x2F;2 三个状态，强制商品按 “生产→分销→购买” 的顺序流转，避免跳过环节的虚假流转（比如直接从生产到购买）—— 后续分销、购买函数会通过该字段判断是否符合流转逻辑。</p></li><li><p>exists字段是 “防错开关”：由于商品用uint类型的goodId作为唯一标识，若用户重复传入同一goodId，exists可直接判断商品是否已存在，避免覆盖原有数据（见 1.4 添加商品函数的判断逻辑）。</p></li><li><p>producer用地址而非名称：区块链中地址具有唯一性，相比 “XX 工厂” 这类可伪造的名称，地址能确保生产商身份不可篡改（后续可通过地址关联线下真实企业信息，比如在链下平台公示 “地址 A 对应 XX 品牌”）。</p></li></ul><h3 id="1-2-设置权限"><a href="#1-2-设置权限" class="headerlink" title="1.2 设置权限"></a>1.2 设置权限</h3><p>添加商品是核心操作（相当于 “创建数字档案”），必须限制只有可信主体（如平台方、品牌方）能执行，否则任何人都能添加虚假商品，导致溯源体系失效。因此我们设计onlyOwner修饰器，仅合约拥有者可调用核心方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">address private _owner;</span><br><span class="line">// 定义modifier</span><br><span class="line">modifier onlyOwner &#123;</span><br><span class="line">require(msg.sender == _owner); // 检查调用者是否为owner地址</span><br><span class="line">_; // 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>权限控制的意义</strong>：合约部署后，_owner会被初始化为部署者地址（见 1.3 构造函数），只有该地址能添加商品 —— 比如品牌方部署合约后，只有品牌方能录入自家商品信息，从源头保证商品基础信息的真实性。</p><h3 id="1-3-构造函数"><a href="#1-3-构造函数" class="headerlink" title="1.3 构造函数"></a>1.3 构造函数</h3><p>构造函数在合约部署时仅执行一次，用于初始化_owner，确定谁拥有合约的最高权限（后续添加商品、管理经销商都需要该权限）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor ()&#123;</span><br><span class="line">    _owner = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举个例子</strong>：若某有机农场部署合约，农场的区块链地址就是_owner，只有农场能添加 “有机蔬菜”“有机水果” 等商品，其他地址无法伪造该农场的商品信息，避免 “假有机” 商品混入溯源体系。</p><h3 id="1-4-添加产品信息"><a href="#1-4-添加产品信息" class="headerlink" title="1.4 添加产品信息"></a>1.4 添加产品信息</h3><p>要将商品信息写入区块链，需通过addNewGood方法，将用户输入的参数与Good结构体关联，并通过mapping实现 “商品 ID→商品信息” 的映射（快速定位商品）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(uint =&gt; Good) private _goods;</span><br></pre></td></tr></table></figure><p>之后写addNewGood方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function addNewGood(uint goodId, string memory name, string memory curentTraceName, uint8 quality) public onlyOwner&#123;</span><br><span class="line">    require(!_goods[goodId].exists, &quot;good exists!&quot;);//判断是否存在</span><br><span class="line">    Good storage newGood = _goods[goodId];//以用户输入的数字Id为key来初始化一个结构体newGood</span><br><span class="line">    newGood.name = name;</span><br><span class="line">    newGood.status = 0;</span><br><span class="line">    newGood.exists = true;</span><br><span class="line">    newGood.producer = msg.sender;</span><br><span class="line">    newGood.quality = quality;</span><br><span class="line">    newGood.currentTraceName = curentTraceName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键逻辑拆解</strong>：</p><ul><li><p>mapping(uint &#x3D;&gt; Good)的作用：类似 “手机通讯录”，goodId是 “联系人姓名”，Good结构体是 “联系人详情”—— 通过goodId&#x3D;1001能直接找到对应的商品信息，查询效率远高于数组遍历（尤其商品数量较多时）。</p></li><li><p>storage newGood &#x3D; _goods[goodId]：storage表示直接操作区块链上的 “永久存储”，后续对newGood的赋值（如newGood.name &#x3D; name）会直接写入区块链，一旦确认就无法修改，确保商品基础信息不可篡改。</p></li><li><p>require(!_goods[goodId].exists)：若用户误传入已存在的goodId（比如重复添加goodId&#x3D;1001），会直接报错 “good exists!”，交易回滚，避免原有商品信息被覆盖。</p></li></ul><h3 id="1-5-查询产品信息"><a href="#1-5-查询产品信息" class="headerlink" title="1.5 查询产品信息"></a>1.5 查询产品信息</h3><p>添加商品后，用户（如消费者、分销商）需要查询商品信息（如名称、当前状态、生产商），因此设计getGood方法，返回商品的核心属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function getGood(uint goodId)public view returns(</span><br><span class="line">    string memory name,</span><br><span class="line">    uint8 status, </span><br><span class="line">    address producer, </span><br><span class="line">    uint8 quality, </span><br><span class="line">    string memory currentTraceName)&#123;</span><br><span class="line">        require(_goods[goodId].exists, &quot;good not exists!&quot;);//判断是否存在</span><br><span class="line">        Good memory good = _goods[goodId];//以用户输入的数字Id来查找匹配的结构体，定义为good</span><br><span class="line">        return (</span><br><span class="line">            good.name,</span><br><span class="line">            good.status,</span><br><span class="line">            good.producer,</span><br><span class="line">            good.quality,</span><br><span class="line">            good.currentTraceName</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为什么用<strong>memory</strong>而非<strong>storage</strong>？</p><p>view修饰的函数仅用于 “读取”，不修改区块链数据。memory表示将商品信息从区块链的 “永久存储（storage）” 复制到 “临时内存” 中，读取速度更快，且不会产生 “修改存储” 的 gas 费用（区块链中 “写数据” 的成本远高于 “读数据”，用memory能降低查询者的成本）。</p><p><strong>查询场景举例</strong>：消费者在超市看到一箱 “有机蔬菜”，包装上标注goodId&#x3D;1001，可通过调用getGood(1001)：</p><ul><li><p>查看producer地址是否为包装上公示的 “XX 有机农场” 地址（验证生产商真伪）；</p></li><li><p>查看status是否为 1（分销阶段，说明商品已通过正规分销流程，不是 “未分销的私货”）；</p></li><li><p>查看quality是否为 9（了解生产阶段的质量评分，判断商品品质）。</p></li></ul><h2 id="2-物品的溯源功能"><a href="#2-物品的溯源功能" class="headerlink" title="2. 物品的溯源功能"></a>2. 物品的溯源功能</h2><p>溯源的核心是 “记录商品从生产到购买的每一个环节”，让每个流转步骤都可查、可验证。因此我们需要设计流转记录结构体，并实现分销、购买环节的记录功能，最终通过查询方法获取全链路溯源信息。</p><h3 id="2-1-定义结构体"><a href="#2-1-定义结构体" class="headerlink" title="2.1 定义结构体"></a>2.1 定义结构体</h3><p>每个流转环节（如生产→分销、分销→购买）都需要记录 “谁在什么时间做了什么，商品质量如何”，因此定义TraceInfo结构体，捕捉每个环节的核心数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TraceInfo&#123;</span><br><span class="line">    uint timestamp;//时间戳</span><br><span class="line">    string traceName;//溯源点名称</span><br><span class="line">    address traceAddress;//操作方账户地址</span><br><span class="line">    uint8 traceQuality;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可篡改的关键</strong>：</p><ul><li><p>timestamp由block.timestamp（区块链区块的时间戳）自动生成，无法人工修改 —— 比如分销环节的时间戳是 “2025-10-23 14:30:00”，后续任何人都无法改成 “2025-10-22”，确保流转时间真实。</p></li><li><p>traceAddress是操作方的真实区块链地址 —— 比如分销商的地址是 “0x123…”，与分销商身份绑定，后续可通过该地址追溯责任（若商品在分销环节出现质量问题，可直接定位到该地址对应的分销商）。</p></li></ul><h3 id="2-2-关联商品与流转记录：让每个商品有自己的-“溯源档案”"><a href="#2-2-关联商品与流转记录：让每个商品有自己的-“溯源档案”" class="headerlink" title="2.2 关联商品与流转记录：让每个商品有自己的 “溯源档案”"></a>2.2 关联商品与流转记录：让每个商品有自己的 “溯源档案”</h3><p>每个商品的流转记录是独立的（比如 “有机蔬菜 1001” 和 “有机蔬菜 1002” 的流转路径不同），因此需要在Good结构体中新增两个字段，将商品与对应的流转信息关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TraceInfo[] traceInfos;//溯源信息历史列表</span><br><span class="line">mapping(address=&gt;bool) purchasedUsers;//购买用户记录</span><br></pre></td></tr></table></figure><p><strong>字段作用详解</strong>：</p><ul><li>traceInfos数组：商品每经历一个流转环节，就会向数组中添加一条TraceInfo，最终数组会按 “时间顺序” 保存全链路记录。例如 “有机蔬菜 1001” 的traceInfos可能是：</li></ul><p>索引 0（生产→分销）：timestamp&#x3D;1740253800（2025-10-23 14:30:00）、traceName&#x3D;“农场交付分销商”、traceAddress &#x3D; 分销商地址、traceQuality&#x3D;9；</p><p>索引 1（分销→购买）：timestamp&#x3D;1740260400（2025-10-23 16:20:00）、traceName&#x3D;“分销商交付消费者”、traceAddress &#x3D; 消费者地址、traceQuality&#x3D;8。</p><ul><li>purchasedUsers映射：key 为买家地址，value 为 “是否购买”（true&#x2F;false）—— 比如消费者 A 的地址调用addTraceByBuyer后，purchasedUsers[A的地址] &#x3D; true，后续可通过该映射快速验证 “A 是否真的购买过该商品”（用于售后维权、正品验证等场景）。</li></ul><h3 id="2-3-分销商流转信息功能"><a href="#2-3-分销商流转信息功能" class="headerlink" title="2.3 分销商流转信息功能"></a>2.3 分销商流转信息功能</h3><p>商品从生产阶段（status&#x3D;0）进入分销阶段（status&#x3D;1）时，需要记录分销商的操作信息，因此设计addTraceByDistributor方法，将分销环节的信息写入区块链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function addTraceByDistributor(</span><br><span class="line">    uint goodId, </span><br><span class="line">    string memory traceName,  </span><br><span class="line">    address distributor, </span><br><span class="line">    uint8 quality)public returns(bool)&#123;</span><br><span class="line">    </span><br><span class="line">    require(_goods[goodId].exists, &quot;good not exists!&quot;);</span><br><span class="line">    require(quality&lt;=10, &quot;Quality exceeds the limit of quality!&quot;); // 检查质量评分是否合法（1-10分）</span><br><span class="line">    Good storage good = _goods[goodId];// 引用该商品的storage数据（后续修改会更新到区块链）</span><br><span class="line">    require(good.status == 0, &quot;The product is already produced!&quot;);// 检查商品当前状态是否为“生产阶段”（0），确保流转顺序正确（生产→分销）</span><br><span class="line">    // 向商品的流转记录列表中添加一条新的TraceInfo（记录本次流转）</span><br><span class="line">    // 包含：当前时间戳、流转名称、分销商地址、质量评分</span><br><span class="line">    good.traceInfos.push(TraceInfo(block.timestamp, traceName, distributor, quality));  </span><br><span class="line">    good.currentTraceName = traceName;// 更新商品当前的流转阶段名称为本次流转名称  </span><br><span class="line">    good.status = 1;// 将商品状态从“生产阶段”（0）更新为“分销阶段”（1）</span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>核心逻辑拆解</strong>：</p><ol><li><p>基础校验：先通过require(_goods[goodId].exists)确认商品存在，避免对 “不存在的商品” 添加流转记录；再通过require(quality&lt;&#x3D;10)确保质量评分符合 “1-10 分” 的约定（避免输入 11、100 等无效分数）。</p></li><li><p>流转顺序控制：require(good.status &#x3D;&#x3D; 0)是关键 —— 只有商品处于 “生产阶段” 时，才能执行分销操作。若商品已处于 “分销阶段”（status&#x3D;1）或 “购买阶段”（status&#x3D;2），调用该方法会报错，避免 “同一商品重复分销”“跳过生产直接分销” 等虚假记录。</p></li><li><p>数据更新：添加TraceInfo记录后，同步更新currentTraceName（让查询者知道商品当前处于哪个流转阶段）和status（锁定下一阶段只能是 “购买”，不能再回退到 “生产”）。</p></li></ol><h3 id="2-4-买家流转信息功能"><a href="#2-4-买家流转信息功能" class="headerlink" title="2.4 买家流转信息功能"></a>2.4 买家流转信息功能</h3><p>买家从分销商处购买商品时，商品从 “分销阶段”（status&#x3D;1）进入 “购买阶段”（status&#x3D;2），需要记录购买环节的信息，设计addTraceByBuyer方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function addTraceByBuyer(</span><br><span class="line">    uint goodId, </span><br><span class="line">    string memory traceName,  </span><br><span class="line">    address buyer, </span><br><span class="line">    uint8 quality)public returns(bool)&#123;</span><br><span class="line">    </span><br><span class="line">    require(_goods[goodId].exists, &quot;good not exists!&quot;);</span><br><span class="line">    require(quality&lt;=10, &quot;Quality exceeds the limit of quality!&quot;); </span><br><span class="line">    Good storage good = _goods[goodId];</span><br><span class="line">    require(good.status == 1, &quot;The product is already produced!&quot;);</span><br><span class="line"></span><br><span class="line">    good.traceInfos.push(TraceInfo(block.timestamp, traceName, buyer, quality));  </span><br><span class="line">    good.currentTraceName = traceName;// 更新当前流转阶段（如“买家已签收”）</span><br><span class="line">    good.status = 2;// 状态改为“购买阶段”（表示商品已被购买）</span><br><span class="line">    good.purchasedUsers[buyer] = true;// 标记该买家已购买该商品</span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键差异与补充</strong>：</p><ul><li><p>流转顺序控制：require(good.status &#x3D;&#x3D; 1)确保商品只能从 “分销阶段” 进入 “购买阶段”，避免 “未分销直接购买”（比如消费者直接从生产阶段买商品，可能是假货）。</p></li><li><p>good.purchasedUsers[buyer] &#x3D; true—— 买家地址被记录到商品的购买者映射中，后续可通过该字段实现 “正品验证”：例如，买家可调用一个验证方法（需自行扩展），输入goodId和自己的地址，若purchasedUsers[msg.sender] &#x3D; true，则证明是正品购买者。</p></li></ul><h3 id="2-5-查询流转信息功能"><a href="#2-5-查询流转信息功能" class="headerlink" title="2.5 查询流转信息功能"></a>2.5 查询流转信息功能</h3><p>用户需要查看商品的所有流转记录时，通过getTraceInfo方法返回traceInfos数组，即可获取从生产到购买的全链路信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getTraceInfo(uint goodId) public view returns(TraceInfo[] memory)&#123;</span><br><span class="line">    return _goods[goodId].traceInfos;// 直接返回该商品的所有流转记录列表（traceInfos是数组，会复制到memory中返回）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>溯源场景举例</strong>：某超市收到一批 “有机蔬菜 1001”，调用getTraceInfo(1001)后，能看到两条记录：</p><ol><li><p>分销记录：时间戳 1740253800、traceName&#x3D;“农场交付分销商”、traceAddress &#x3D; 农场合作的正规分销商地址、traceQuality&#x3D;9—— 确认分销商是可信的；</p></li><li><p>（若已售出）购买记录：时间戳 1740260400、traceName&#x3D;“超市交付消费者”、traceAddress &#x3D; 消费者地址、traceQuality&#x3D;8—— 消费者可通过自己的地址验证这条记录，确认买到的是 “经过正规流转的正品”。</p></li></ol><h2 id="3-优化"><a href="#3-优化" class="headerlink" title="3. 优化"></a>3. 优化</h2><p>但现在合约还有一个问题就是，不管是谁都都可以调用addTraceByDistributor()哪怕不是经销商，所以应该加一个限制条件，使得只有合约拥有者Owner指定的经销商可以调用addTraceByDistributor()</p><p>第一步：新增授权经销商映射</p><p>用mapping存储 “地址→是否为授权经销商” 的关系，快速判断调用者是否有权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 新增：存储被授权的经销商（address =&gt; 是否授权）</span><br><span class="line">mapping(address =&gt; bool) private _authorizedDistributors;</span><br></pre></td></tr></table></figure><p>第二步：新增经销商权限修饰器</p><p>定义onlyDistributor修饰器，仅授权经销商能调用被修饰的方法（后续给addTraceByDistributor加该修饰器）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 新增：仅授权经销商可调用</span><br><span class="line">modifier onlyDistributor &#123;</span><br><span class="line">    require(_authorizedDistributors[msg.sender], &quot;Not authorized distributor&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：新增经销商管理方法</p><p>由owner（合约拥有者）统一管理经销商列表，实现 “添加授权” 和 “移除授权”（仅 owner 能调用，确保管理权限唯一）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 新增：owner授权经销商（仅owner可调用）</span><br><span class="line">function addDistributor(address distributor) public onlyOwner &#123;</span><br><span class="line">    _authorizedDistributors[distributor] = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新增：owner移除经销商授权（仅owner可调用）</span><br><span class="line">function removeDistributor(address distributor) public onlyOwner &#123;</span><br><span class="line">    _authorizedDistributors[distributor] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步：给分销方法添加权限限制（仅加修饰器，不改其他代码）</p><p>在原有addTraceByDistributor方法的基础上，仅添加onlyDistributor修饰器，限制调用权限，其他代码完全保留：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 分销商流转信息（仅授权经销商可调用）</span><br><span class="line">function addTraceByDistributor(</span><br><span class="line">    uint goodId, </span><br><span class="line">    string memory traceName,  </span><br><span class="line">    uint8 quality)public onlyDistributor returns(bool)&#123; // 新增onlyDistributor修饰符，移除多余的distributor参数</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结：区块链溯源的价值与应用场景"><a href="#4-总结：区块链溯源的价值与应用场景" class="headerlink" title="4. 总结：区块链溯源的价值与应用场景"></a>4. 总结：区块链溯源的价值与应用场景</h2><p>本合约通过 “商品基础信息管理 + 全链路流转记录 + 精准权限控制”，实现了物品的区块链溯源功能，其核心价值在于：</p><ol><li><p><strong>不可篡改</strong>：商品信息和流转记录写入区块链后，任何主体都无法修改（包括 owner），确保数据真实可信；</p></li><li><p><strong>全链路可追溯</strong>：从生产到购买的每个环节都有时间戳、操作方地址记录，用户可通过getTraceInfo查询 “商品的每一步去向”；</p></li><li><p><strong>权限可控</strong>：核心操作（添加商品、授权经销商）仅由 owner 执行，分销操作仅授权经销商可执行，防止恶意伪造数据。</p></li></ol><p><strong>实际应用场景</strong>：</p><ul><li><p>食品溯源：记录食材从 “种植（生产）→加工→运输（分销）→超市（购买）” 的全环节，消费者扫码即可查看 “蔬菜是否用了合规农药”“运输过程是否冷藏”；</p></li><li><p>奢侈品防伪：奢侈品出厂时生成goodId，流转记录（品牌方→代理商→门店→消费者）上链，消费者可验证 “自己买的包是否经过品牌授权的分销链路”；</p></li><li><p>药品溯源：记录药品从 “药厂生产→医药公司分销→医院 &#x2F; 药店购买” 的流程，避免假药通过 “非授权链路” 流入市场。</p></li></ul><p>后续可进一步扩展功能（不修改现有代码）：比如添加 “根据买家地址查询已购商品” 的方法（利用purchasedUsers映射）、“质量评分统计” 方法（计算traceInfos中traceQuality的平均值），让溯源体系更贴合实际需求。</p><h2 id="5-结果展示"><a href="#5-结果展示" class="headerlink" title="5. 结果展示"></a>5. 结果展示</h2><p>首先使用Owner部署合约，地址为0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</p><p>并创建新物品</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/addgoods.png" alt="image-20251023231830121" style="zoom: 67%;" /><p>之后给授权经销商，经销商地址为0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/adddistributor.png" alt="image-20251023230547128" style="zoom:67%;" /><p>之后换成经销商地址，对产品信息进行编辑</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/addtracebydistributor.png" alt="image-20251023230836433" style="zoom:67%;" /><p>最后换成买家地址</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/addtracebybuyer.png" alt="image-20251023230958400" style="zoom:67%;" /><p>同时随时都可以看到物品实时的情况</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/good.png" alt="image-20251023231119936" style="zoom:67%;" /><h2 id="6-完整代码展示"><a href="#6-完整代码展示" class="headerlink" title="6. 完整代码展示"></a>6. 完整代码展示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract goodInfoItem&#123;</span><br><span class="line">    struct Good&#123;</span><br><span class="line">        string name;</span><br><span class="line">        string currentTraceName; //当前流转阶段名称</span><br><span class="line">        uint8 quality; //综合评分1-10</span><br><span class="line">        uint8 status; //物品状态 0=生产；1=分销； 2=购买</span><br><span class="line">        address producer;</span><br><span class="line">        bool exists;//物品存在标志</span><br><span class="line">        TraceInfo[] traceInfos;//溯源信息历史列表</span><br><span class="line">    mapping(address=&gt;bool) purchasedUsers;//购买用户记录</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct TraceInfo&#123;</span><br><span class="line">        uint timestamp;//时间戳</span><br><span class="line">        string traceName;//溯源点名称</span><br><span class="line">        address traceAddress;//操作方账户地址</span><br><span class="line">        uint8 traceQuality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mapping(uint =&gt; Good) private _goods;</span><br><span class="line">    // 新增：存储被授权的经销商（address =&gt; 是否授权）</span><br><span class="line">    mapping(address =&gt; bool) private _authorizedDistributors;</span><br><span class="line"></span><br><span class="line">    address private _owner;</span><br><span class="line">    // 定义modifier</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">    require(msg.sender == _owner); // 检查调用者是否为owner地址</span><br><span class="line">    _; // 如果是的话，继续运行函数主体；否则报错并revert交易</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 新增：仅授权经销商可调用</span><br><span class="line">    modifier onlyDistributor &#123;</span><br><span class="line">        require(_authorizedDistributors[msg.sender], &quot;Not authorized distributor&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor ()&#123;</span><br><span class="line">        _owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加产品信息</span><br><span class="line">    function addNewGood(uint goodId, string memory name, string memory curentTraceName, uint8 quality) public onlyOwner&#123;</span><br><span class="line">        require(!_goods[goodId].exists, &quot;good exists!&quot;);//判断是否存在</span><br><span class="line">        Good storage newGood = _goods[goodId];</span><br><span class="line">        newGood.name = name;</span><br><span class="line">        newGood.status = 0;</span><br><span class="line">        newGood.exists = true;</span><br><span class="line">        newGood.producer = msg.sender;</span><br><span class="line">        newGood.quality = quality;</span><br><span class="line">        newGood.currentTraceName = curentTraceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 新增：owner授权经销商（仅owner可调用）</span><br><span class="line">    function addDistributor(address distributor) public onlyOwner &#123;</span><br><span class="line">        _authorizedDistributors[distributor] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 新增：owner移除经销商授权（仅owner可调用）</span><br><span class="line">    function removeDistributor(address distributor) public onlyOwner &#123;</span><br><span class="line">        _authorizedDistributors[distributor] = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查询产品信息</span><br><span class="line">    function getGood(uint goodId)public view returns(</span><br><span class="line">        string memory name,</span><br><span class="line">        uint8 status, </span><br><span class="line">        address producer, </span><br><span class="line">        uint8 quality, </span><br><span class="line">        string memory currentTraceName)&#123;</span><br><span class="line">            require(_goods[goodId].exists, &quot;good not exists!&quot;);//判断是否存在</span><br><span class="line">            Good storage good = _goods[goodId];</span><br><span class="line">            return (</span><br><span class="line">                good.name,</span><br><span class="line">                good.status,</span><br><span class="line">                good.producer,</span><br><span class="line">                good.quality,</span><br><span class="line">                good.currentTraceName</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //分销商流转信息</span><br><span class="line">    function addTraceByDistributor(</span><br><span class="line">        uint goodId, </span><br><span class="line">        string memory traceName,  </span><br><span class="line">        address distributor, </span><br><span class="line">        uint8 quality)public onlyDistributor returns(bool)&#123;</span><br><span class="line">        </span><br><span class="line">        require(_goods[goodId].exists, &quot;good not exists!&quot;);</span><br><span class="line">        require(quality&lt;=10, &quot;Quality exceeds the limit of quality!&quot;); // 检查质量评分是否合法（1-10分）</span><br><span class="line">        Good storage good = _goods[goodId];// 引用该商品的storage数据（后续修改会更新到区块链）</span><br><span class="line">        require(good.status == 0, &quot;The product is already produced!&quot;);// 检查商品当前状态是否为“生产阶段”（0），确保流转顺序正确（生产→分销）</span><br><span class="line">        // 向商品的流转记录列表中添加一条新的TraceInfo（记录本次流转）</span><br><span class="line">        // 包含：当前时间戳、流转名称、分销商地址、质量评分</span><br><span class="line">        good.traceInfos.push(TraceInfo(block.timestamp, traceName, distributor, quality));  </span><br><span class="line">        good.currentTraceName = traceName;// 更新商品当前的流转阶段名称为本次流转名称  </span><br><span class="line">        good.status = 1;// 将商品状态从“生产阶段”（0）更新为“分销阶段”（1）</span><br><span class="line">        return true;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //买家流转信息</span><br><span class="line">    function addTraceByBuyer(</span><br><span class="line">        uint goodId, </span><br><span class="line">        string memory traceName,  </span><br><span class="line">        address buyer, </span><br><span class="line">        uint8 quality)public returns(bool)&#123;</span><br><span class="line">        </span><br><span class="line">        require(_goods[goodId].exists, &quot;good not exists!&quot;);</span><br><span class="line">        require(quality&lt;=10, &quot;Quality exceeds the limit of quality!&quot;); </span><br><span class="line">        Good storage good = _goods[goodId];</span><br><span class="line">        require(good.status == 1, &quot;The product is already produced!&quot;);</span><br><span class="line">    </span><br><span class="line">        good.traceInfos.push(TraceInfo(block.timestamp, traceName, buyer, quality));  </span><br><span class="line">        good.currentTraceName = traceName;</span><br><span class="line">        good.status = 2;</span><br><span class="line">        return true;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查询流转信息</span><br><span class="line">    function getTraceInfo(uint goodId) public view returns(TraceInfo[] memory)&#123;</span><br><span class="line">        return _goods[goodId].traceInfos;// 直接返回该商品的所有流转记录列表（traceInfos是数组，会复制到memory中返回）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：学习来源b站up主发呆Jay，视频地址 <a href="https://www.bilibili.com/video/BV1QkTkzuEvk/?share_source=copy_web&vd_source=1a7d0036808273fc1991ef595f5b089d">https://www.bilibili.com/video/BV1QkTkzuEvk/?share_source=copy_web&amp;vd_source=1a7d0036808273fc1991ef595f5b089d</a></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity入门第一课</title>
      <link href="/2025/09/10/solidity_session1/"/>
      <url>/2025/09/10/solidity_session1/</url>
      
        <content type="html"><![CDATA[<h1 id="Solidity入门第一课：从零实现HelloWorld合约，吃透核心数据类型与基础逻辑"><a href="#Solidity入门第一课：从零实现HelloWorld合约，吃透核心数据类型与基础逻辑" class="headerlink" title="Solidity入门第一课：从零实现HelloWorld合约，吃透核心数据类型与基础逻辑"></a>Solidity入门第一课：从零实现HelloWorld合约，吃透核心数据类型与基础逻辑</h1><p>作为区块链开发的入门基石，Solidity是以太坊及众多EVM（以太坊虚拟机）兼容链的智能合约编程语言。本节课我们将通过一个完整的<code>HelloWorld</code>合约，拆解Solidity的基础语法、核心数据类型、复合结构（结构体&#x2F;数组&#x2F;映射）及函数设计逻辑，帮你建立Solidity开发的第一套知识框架。</p><h2 id="一、合约基础框架：从“头部声明”开始"><a href="#一、合约基础框架：从“头部声明”开始" class="headerlink" title="一、合约基础框架：从“头部声明”开始"></a>一、合约基础框架：从“头部声明”开始</h2><p>任何Solidity合约的开头都需要两个核心声明：<strong>SPDX许可证</strong>和<strong>编译器版本指定</strong>，这是合约合法性与兼容性的基础。我们先看完整合约的头部代码，再逐一解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract HelloWorld&#123;</span><br><span class="line">    // 合约主体内容...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-SPDX许可证：明确代码开源协议"><a href="#1-SPDX许可证：明确代码开源协议" class="headerlink" title="1. SPDX许可证：明确代码开源协议"></a>1. SPDX许可证：明确代码开源协议</h3><p><code>//SPDX-License-Identifier:MIT</code> 是Solidity 0.6.8及以上版本的强制要求（虽非语法报错，但属于行业规范），作用是声明合约代码的开源许可证类型。</p><ul><li><strong>MIT许可证</strong>：最宽松的开源协议之一，允许任何人自由使用、修改、分发代码，仅需保留原许可证声明，非常适合学习和开源项目。</li><li>其他常见许可证：<code>GPL-3.0</code>（要求修改后的代码同样开源）、<code>Apache-2.0</code>（商用友好，需保留版权声明）。</li></ul><h3 id="2-编译器版本指定：避免兼容性问题"><a href="#2-编译器版本指定：避免兼容性问题" class="headerlink" title="2. 编译器版本指定：避免兼容性问题"></a>2. 编译器版本指定：避免兼容性问题</h3><p><code>pragma solidity ^0.8.20;</code> 用于指定合约兼容的Solidity编译器版本，其中：</p><ul><li><code>pragma</code>：Solidity的关键字，意为“编译指令”。</li><li><code>^0.8.20</code>：表示“兼容0.8.20及以上版本，但不兼容9.0.0及更高主版本”（遵循语义化版本规范）。<ul><li>为什么选0.8.x？0.8.0及以上版本内置了<strong>溢出检查</strong>（无需再引入<code>SafeMath</code>库），且修复了多个安全漏洞，是目前主流的稳定版本。</li></ul></li></ul><h2 id="二、核心数据类型：合约的“基本积木”"><a href="#二、核心数据类型：合约的“基本积木”" class="headerlink" title="二、核心数据类型：合约的“基本积木”"></a>二、核心数据类型：合约的“基本积木”</h2><p>Solidity的数据类型分为<strong>值类型</strong>（存储具体值）和<strong>引用类型</strong>（存储地址，指向实际数据）。我们先从合约中定义的基础值类型开始讲解。</p><h3 id="1-布尔型（bool）：真-假判断"><a href="#1-布尔型（bool）：真-假判断" class="headerlink" title="1. 布尔型（bool）：真&#x2F;假判断"></a>1. 布尔型（bool）：真&#x2F;假判断</h3><p>布尔型是最简单的数据类型，仅包含<code>true</code>（真）和<code>false</code>（假）两个值，常用于条件判断（如“是否已初始化”“权限是否开启”）。</p><p>合约中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool boolVar_1 = true;</span><br><span class="line">bool boolVar_2 = false;</span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>：比如判断某个用户是否已注册（<code>isRegistered = true</code>）、某个功能是否已启用（<code>isActive = false</code>）。</li><li><strong>注意</strong>：布尔型不能与其他类型（如整数）直接比较，需严格用<code>== true</code>或<code>== false</code>判断。</li></ul><h3 id="2-整数型（uint-int）：数值存储的核心"><a href="#2-整数型（uint-int）：数值存储的核心" class="headerlink" title="2. 整数型（uint&#x2F;int）：数值存储的核心"></a>2. 整数型（uint&#x2F;int）：数值存储的核心</h3><p>整数型是Solidity中最常用的类型，分为<strong>无符号整数（uint）</strong> 和<strong>有符号整数（int）</strong>，两者均需指定“位数”（表示存储范围）。</p><p>合约中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无符号整数：只能存储非负整数（0及以上）</span><br><span class="line">uint256 uintVar = 123123;</span><br><span class="line">// 有符号整数：可存储正、负、零</span><br><span class="line">int256 intVar = -1;</span><br></pre></td></tr></table></figure><h4 id="关键细节："><a href="#关键细节：" class="headerlink" title="关键细节："></a>关键细节：</h4><ul><li><strong>位数含义</strong>：<code>uint256</code>表示“256位无符号整数”，存储范围是<code>0 ~ 2^256 - 1</code>（约1.15e77，足够存储极大数值）；<code>int256</code>表示“256位有符号整数”，存储范围是<code>-2^255 ~ 2^255 - 1</code>。</li><li><strong>为什么首选256位？</strong> EVM（以太坊虚拟机）对256位数据的处理效率最高，即使存储小数值（如100），用<code>uint256</code>也比<code>uint8</code>（8位，范围0~255）更省gas（因为EVM会自动将小位数扩展为256位处理）。</li><li><strong>简写规则</strong>：<code>uint</code>默认等价于<code>uint256</code>，<code>int</code>默认等价于<code>int256</code>，开发中可简写（如<code>uint num = 100;</code>）。</li></ul><h3 id="3-字节与字符串（bytes-string）：文本存储"><a href="#3-字节与字符串（bytes-string）：文本存储" class="headerlink" title="3. 字节与字符串（bytes&#x2F;string）：文本存储"></a>3. 字节与字符串（bytes&#x2F;string）：文本存储</h3><p>Solidity中存储文本有两种核心类型：<code>bytes</code>（字节数组）和<code>string</code>（字符串），两者本质都是字节序列，但适用场景不同。</p><p>合约中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 固定长度字节数组：长度32字节，存储效率高</span><br><span class="line">bytes32 bytesVar = &quot;Hello World!&quot; ;</span><br><span class="line">// 动态长度字符串：长度随内容动态变化，灵活性高</span><br><span class="line">string strVar = &quot;Hello World!&quot;;</span><br></pre></td></tr></table></figure><h4 id="核心区别与使用场景："><a href="#核心区别与使用场景：" class="headerlink" title="核心区别与使用场景："></a>核心区别与使用场景：</h4><table><thead><tr><th>类型</th><th>长度特性</th><th>存储效率</th><th>适用场景</th></tr></thead><tbody><tr><td><code>bytesN</code></td><td>固定长度（N为1~32）</td><td>高</td><td>短文本、哈希值、固定格式数据（如身份证号）</td></tr><tr><td><code>string</code></td><td>动态长度</td><td>中</td><td>变长文本（如用户昵称、文章内容）</td></tr><tr><td><code>bytes</code></td><td>动态长度字节数组</td><td>高</td><td>二进制数据（如图片片段、加密数据）</td></tr></tbody></table><ul><li><strong>补充</strong>：<code>string</code>本质是“UTF-8编码的动态字节数组”，但不能直接与<code>bytes</code>转换，需通过<code>abi.encodePacked()</code>或<code>string()</code>函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// string转bytes</span><br><span class="line">bytes memory strToBytes = bytes(strVar);</span><br><span class="line">// bytes转string</span><br><span class="line">string memory bytesToString = string(bytesVar);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-地址类型（address）：区块链账户的“身份证”"><a href="#4-地址类型（address）：区块链账户的“身份证”" class="headerlink" title="4. 地址类型（address）：区块链账户的“身份证”"></a>4. 地址类型（address）：区块链账户的“身份证”</h3><p><code>address</code>类型用于存储以太坊账户地址（包括<strong>外部账户</strong>（用户钱包）和<strong>合约账户</strong>（智能合约）），长度固定为20字节（对应40个十六进制字符）。</p><p>合约中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address addrVar = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;</span><br></pre></td></tr></table></figure><h4 id="关键特性与常用操作："><a href="#关键特性与常用操作：" class="headerlink" title="关键特性与常用操作："></a>关键特性与常用操作：</h4><ul><li><strong>地址零值</strong>：未初始化的<code>address</code>默认值为<code>0x0000000000000000000000000000000000000000</code>（简称<code>address(0)</code>），常用于判断地址是否已赋值（如合约中的<code>infoMapping[_id].addr == address(0)</code>）。</li><li><strong>核心方法</strong>：<code>address</code>类型自带ETH转账相关方法，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 向指定地址转账ETH（单位：wei，1ETH=1e18wei）</span><br><span class="line">addrVar.transfer(1 ether);</span><br><span class="line">// 调用外部合约函数（低级别调用）</span><br><span class="line">(bool success, ) = addrVar.call(abi.encodeWithSignature(&quot;funcName()&quot;));</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、复合数据类型：组织复杂数据的“工具”"><a href="#三、复合数据类型：组织复杂数据的“工具”" class="headerlink" title="三、复合数据类型：组织复杂数据的“工具”"></a>三、复合数据类型：组织复杂数据的“工具”</h2><p>当基础类型无法满足需求时（如存储“用户信息”“订单数据”），需要用<strong>结构体（struct）</strong>、<strong>数组（array）</strong>、<strong>映射（mapping）</strong> 等复合类型来组织数据。</p><h3 id="1-结构体（struct）：自定义复合类型"><a href="#1-结构体（struct）：自定义复合类型" class="headerlink" title="1. 结构体（struct）：自定义复合类型"></a>1. 结构体（struct）：自定义复合类型</h3><p>结构体允许将多个不同类型的变量“打包”成一个新类型，类似其他语言的“类”或“数据模型”，适合存储结构化数据。</p><p>合约中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义结构体Info，包含3个字段</span><br><span class="line">struct Info&#123;</span><br><span class="line">    string phrase;  // 文本内容</span><br><span class="line">    uint256 id;     // 唯一标识</span><br><span class="line">    address addr;   // 关联账户地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>：比如存储用户信息（<code>struct User &#123; string name; uint age; address wallet; &#125;</code>）、订单信息（<code>struct Order &#123; uint orderId; uint amount; address buyer; &#125;</code>）。</li><li><strong>初始化方式</strong>：通过“结构体构造函数”直接初始化，如合约中<code>setHelloWorld</code>函数的写法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Info memory info = Info(newString, _id, msg.sender);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-数组（array）：有序数据集合"><a href="#2-数组（array）：有序数据集合" class="headerlink" title="2. 数组（array）：有序数据集合"></a>2. 数组（array）：有序数据集合</h3><p>数组是有序存储相同类型数据的集合，分为<strong>固定长度数组</strong>和<strong>动态长度数组</strong>，适合存储多个同类型的结构体或基础类型数据。</p><p>合约中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 动态长度数组：存储Info结构体，长度可动态增减</span><br><span class="line">Info[] infos;</span><br></pre></td></tr></table></figure><h4 id="核心特性："><a href="#核心特性：" class="headerlink" title="核心特性："></a>核心特性：</h4><ul><li><strong>固定长度数组</strong>：定义时指定长度（如<code>Info[5] fixedInfos;</code>），长度不可修改，访问时通过索引（从0开始）。</li><li><strong>动态长度数组</strong>：定义时不指定长度（如<code>Info[] infos;</code>），可通过<code>push()</code>添加元素、<code>pop()</code>删除最后一个元素：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 向动态数组添加元素</span><br><span class="line">infos.push(Info(&quot;Test&quot;, 2, msg.sender));</span><br><span class="line">// 删除数组最后一个元素</span><br><span class="line">infos.pop();</span><br><span class="line">// 访问数组元素（索引0为第一个元素）</span><br><span class="line">Info memory firstInfo = infos[0];</span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：数组索引从0开始，且不能越界（如访问<code>infos[10]</code>但数组只有5个元素，会触发合约异常）。</li></ul><h3 id="3-映射（mapping）：键值对快速查询"><a href="#3-映射（mapping）：键值对快速查询" class="headerlink" title="3. 映射（mapping）：键值对快速查询"></a>3. 映射（mapping）：键值对快速查询</h3><p>映射是Solidity中用于“键值对”存储的结构，类似Python的<code>dict</code>、JavaScript的<code>Object</code>，查询效率极高（时间复杂度O(1)），适合通过“唯一键”快速查找对应数据。</p><p>合约中的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 映射：键为uint256类型的id，值为Info结构体</span><br><span class="line">mapping(uint256 id =&gt; Info info) infoMapping;</span><br></pre></td></tr></table></figure><h4 id="关键特性与注意事项："><a href="#关键特性与注意事项：" class="headerlink" title="关键特性与注意事项："></a>关键特性与注意事项：</h4><ul><li><strong>键与值的类型</strong>：键可以是<code>uint</code>、<code>address</code>、<code>bytes</code>等“值类型”，但不能是<code>string</code>、<code>array</code>、<code>struct</code>等引用类型；值可以是任意类型（包括结构体、数组、映射）。</li><li><strong>默认值</strong>：映射中未赋值的键，其对应的值为“类型零值”（如<code>infoMapping[999]</code>未赋值时，<code>phrase</code>为空字符串，<code>id</code>为0，<code>addr</code>为<code>address(0)</code>）。</li><li><strong>无法遍历</strong>：映射不存储“键的列表”，因此无法直接遍历所有键值对。若需遍历，需额外用数组存储所有键（如<code>uint256[] allIds;</code>），添加映射时同步将键存入数组。</li></ul><h2 id="四、函数设计：合约的“行为逻辑”"><a href="#四、函数设计：合约的“行为逻辑”" class="headerlink" title="四、函数设计：合约的“行为逻辑”"></a>四、函数设计：合约的“行为逻辑”</h2><p>函数是合约的核心执行单元，定义了合约的“可调用行为”。Solidity中函数需指定<strong>可见性</strong>和<strong>状态修饰符</strong>，以控制访问权限和状态交互方式。</p><h3 id="1-函数的核心属性"><a href="#1-函数的核心属性" class="headerlink" title="1. 函数的核心属性"></a>1. 函数的核心属性</h3><p>先明确两个关键概念，再解析合约中的函数：</p><table><thead><tr><th>属性类型</th><th>可选值</th><th>作用</th></tr></thead><tbody><tr><td><strong>可见性</strong></td><td><code>public</code>、<code>private</code>、<code>internal</code>、<code>external</code></td><td>控制函数可被哪些主体调用</td></tr><tr><td><strong>状态修饰符</strong></td><td><code>view</code>、<code>pure</code>、<code>payable</code></td><td>控制函数是否读取&#x2F;修改合约状态、是否接收ETH</td></tr><tr><td><strong>返回值</strong></td><td>通过<code>returns (类型 变量名)</code>指定，可返回多个值</td><td>定义函数执行后的输出结果</td></tr></tbody></table><h4 id="（1）可见性详解"><a href="#（1）可见性详解" class="headerlink" title="（1）可见性详解"></a>（1）可见性详解</h4><ul><li><code>public</code>：最宽松，合约内、合约外（外部账户&#x2F;其他合约）、子合约均可调用（如<code>sayHello</code>、<code>setHelloWorld</code>）。</li><li><code>private</code>：最严格，仅当前合约内可调用，子合约也无法调用。</li><li><code>internal</code>：仅当前合约或其子合约可调用，外部账户&#x2F;其他合约无法调用（如<code>addinfo</code>）。</li><li><code>external</code>：仅合约外（外部账户&#x2F;其他合约）可调用，当前合约内需通过<code>this.函数名()</code>调用（适合外部高频调用的函数，更省gas）。</li></ul><h4 id="（2）状态修饰符详解"><a href="#（2）状态修饰符详解" class="headerlink" title="（2）状态修饰符详解"></a>（2）状态修饰符详解</h4><ul><li><code>view</code>：<strong>只读函数</strong>，仅读取合约状态变量（不修改），外部调用时不消耗gas（如<code>sayHello</code>，仅读取<code>infoMapping</code>和<code>strVar</code>）。</li><li><code>pure</code>：<strong>纯运算函数</strong>，不读取也不修改合约状态，仅对输入参数做运算，外部调用时不消耗gas（如<code>addinfo</code>，仅做字符串拼接）。</li><li><code>payable</code>：<strong>可接收ETH的函数</strong>，调用时可附带ETH（通过<code>msg.value</code>获取附带的ETH数量），如“购买商品”“捐赠”函数。</li></ul><h3 id="2-合约函数逐句解析"><a href="#2-合约函数逐句解析" class="headerlink" title="2. 合约函数逐句解析"></a>2. 合约函数逐句解析</h3><p>合约中定义了3个函数：<code>sayHello</code>、<code>setHelloWorld</code>、<code>addinfo</code>，我们逐一拆解：</p><h4 id="（1）sayHello：查询型函数"><a href="#（1）sayHello：查询型函数" class="headerlink" title="（1）sayHello：查询型函数"></a>（1）sayHello：查询型函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(uint256 _id) public view returns(string memory)&#123;</span><br><span class="line">    if(infoMapping[_id].addr == address(0))&#123;</span><br><span class="line">        return addinfo(strVar);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return addinfo(infoMapping[_id].phrase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：根据传入的<code>_id</code>查询映射中的<code>Info</code>，返回拼接后的文本。</li><li><strong>逻辑拆解</strong>：<ol><li>判断<code>infoMapping[_id].addr</code>是否为零地址（即该<code>_id</code>是否已通过<code>setHelloWorld</code>设置）；</li><li>若未设置（零地址），调用<code>addinfo</code>函数，传入默认的<code>strVar</code>（“Hello World!”）；</li><li>若已设置，调用<code>addinfo</code>函数，传入映射中存储的<code>phrase</code>；</li><li>返回<code>addinfo</code>拼接后的结果。</li></ol></li><li><strong>关键细节</strong>：<code>_id</code>参数加下划线是Solidity的命名规范，用于区分“函数参数”和“状态变量”（避免命名冲突）。</li></ul><h4 id="（2）setHelloWorld：写入型函数"><a href="#（2）setHelloWorld：写入型函数" class="headerlink" title="（2）setHelloWorld：写入型函数"></a>（2）setHelloWorld：写入型函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setHelloWorld(string memory newString, uint256 _id) public &#123;</span><br><span class="line">    Info memory info = Info(newString, _id, msg.sender);</span><br><span class="line">    infoMapping[_id] = info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：将用户传入的<code>newString</code>和<code>_id</code>，结合调用者地址（<code>msg.sender</code>），存储到<code>infoMapping</code>映射中。</li><li><strong>逻辑拆解</strong>：<ol><li>定义<code>Info</code>类型的<code>memory</code>变量<code>info</code>，通过结构体构造函数初始化（参数：<code>newString</code>、<code>_id</code>、<code>msg.sender</code>）；</li><li>将<code>info</code>赋值给<code>infoMapping[_id]</code>，完成数据写入（<code>infoMapping</code>是<code>storage</code>类型，数据会永久存储在区块链上）。</li></ol></li><li><strong>核心全局变量</strong>：<code>msg.sender</code>是Solidity的内置全局变量，表示“当前调用函数的账户地址”（外部账户或合约账户），常用于记录“操作人”（如谁修改了数据）。</li></ul><h4 id="（3）addinfo：内部工具函数"><a href="#（3）addinfo：内部工具函数" class="headerlink" title="（3）addinfo：内部工具函数"></a>（3）addinfo：内部工具函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function addinfo(string memory helloWorldStr) internal pure returns (string memory)&#123;</span><br><span class="line">    // concat：Solidity 0.8.12+支持的字符串拼接函数</span><br><span class="line">    return string.concat(helloWorldStr,&quot;From HSL&#x27;s contract.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>功能</strong>：内部工具函数，接收一个字符串，返回拼接“From HSL’s contract.”后的结果。</li><li><strong>关键细节</strong>：<ol><li><code>internal</code>可见性：仅<code>HelloWorld</code>合约内部可调用（如<code>sayHello</code>），外部无法直接调用；</li><li><code>pure</code>修饰符：仅做字符串拼接，不读不写合约状态；</li><li><code>string.concat</code>：Solidity 0.8.12及以上版本新增的字符串拼接函数，若使用更低版本，需用<code>abi.encodePacked()</code>替代：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return string(abi.encodePacked(helloWorldStr, &quot;From HSL&#x27;s contract.&quot;));</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="五、存储位置：数据存在哪里？"><a href="#五、存储位置：数据存在哪里？" class="headerlink" title="五、存储位置：数据存在哪里？"></a>五、存储位置：数据存在哪里？</h2><p>Solidity中数据的存储位置决定了“生命周期”和“gas消耗”，合约注释中提到了<code>storage</code>、<code>memory</code>、<code>calldata</code>等，这里展开详解：</p><table><thead><tr><th>存储位置</th><th>生命周期</th><th>可修改性</th><th>适用场景</th><th>gas消耗</th></tr></thead><tbody><tr><td><code>storage</code></td><td>永久存储（区块链上）</td><td>可修改</td><td>合约状态变量（如<code>infoMapping</code>）</td><td>高（写入需消耗gas）</td></tr><tr><td><code>memory</code></td><td>函数执行期间（EVM内存）</td><td>可修改</td><td>函数内临时数据（如<code>info</code>变量）</td><td>低（仅内存占用）</td></tr><tr><td><code>calldata</code></td><td>函数调用期间（输入参数）</td><td>不可修改</td><td>外部函数的引用类型参数（如<code>string</code>）</td><td>极低（无需复制）</td></tr><tr><td><code>stack</code></td><td>函数执行期间（栈）</td><td>可修改</td><td>简单局部变量（<code>uint</code>、<code>bool</code>）</td><td>极低（容量有限，最多1024元素）</td></tr><tr><td><code>code</code></td><td>永久存储（区块链上）</td><td>不可修改</td><td>合约代码本身</td><td>无（部署时一次性消耗）</td></tr><tr><td><code>logs</code></td><td>永久存储（区块链上）</td><td>不可修改</td><td>事件日志（用于前端监听）</td><td>低（按日志长度计费）</td></tr></tbody></table><h3 id="核心规则："><a href="#核心规则：" class="headerlink" title="核心规则："></a>核心规则：</h3><ul><li>状态变量默认是<code>storage</code>，函数参数&#x2F;局部引用类型（如<code>string</code>、<code>array</code>）需显式指定<code>memory</code>或<code>calldata</code>；</li><li><code>storage</code>变量赋值给<code>memory</code>变量：复制值（修改<code>memory</code>变量不影响<code>storage</code>）；</li><li><code>memory</code>变量赋值给<code>storage</code>变量：覆盖值（修改会永久写入区块链）。</li></ul><h2 id="六、合约部署与调用：动手实践"><a href="#六、合约部署与调用：动手实践" class="headerlink" title="六、合约部署与调用：动手实践"></a>六、合约部署与调用：动手实践</h2><p>学习Solidity最好的方式是“边写边测”，这里推荐用<strong>Remix IDE</strong>（以太坊官方在线IDE，无需安装）快速部署和测试合约：</p><h3 id="步骤1：打开Remix并创建合约"><a href="#步骤1：打开Remix并创建合约" class="headerlink" title="步骤1：打开Remix并创建合约"></a>步骤1：打开Remix并创建合约</h3><ol><li>访问Remix官网：<a href="https://remix.ethereum.org/">https://remix.ethereum.org/</a></li><li>在左侧“File Explorer”面板，点击<code>+</code>号，创建<code>HelloWorld.sol</code>文件，粘贴完整合约代码。</li></ol><h3 id="步骤2：编译合约"><a href="#步骤2：编译合约" class="headerlink" title="步骤2：编译合约"></a>步骤2：编译合约</h3><ol><li>切换到左侧“Solidity Compiler”面板；</li><li>编译器版本选择<code>0.8.20</code>（或更高），点击“Compile HelloWorld.sol”，出现绿色对勾表示编译成功。</li></ol><h3 id="步骤3：部署合约"><a href="#步骤3：部署合约" class="headerlink" title="步骤3：部署合约"></a>步骤3：部署合约</h3><ol><li>切换到左侧“Deploy &amp; Run Transactions”面板；</li><li>“Environment”选择<code>Remix VM (London)</code>（测试环境，提供免费测试ETH）；</li><li>点击“Deploy”按钮，合约部署成功后会显示在下方“Deployed Contracts”列表中。</li></ol><h3 id="步骤4：调用函数"><a href="#步骤4：调用函数" class="headerlink" title="步骤4：调用函数"></a>步骤4：调用函数</h3><ol><li><strong>调用setHelloWorld</strong>：<ul><li>在<code>setHelloWorld</code>输入框中，<code>newString</code>填<code>&quot;Hi Solidity!&quot;</code>，<code>_id</code>填<code>1</code>；</li><li>点击<code>transact</code>按钮，弹出确认框后点击“Confirm”，消耗少量测试ETH；</li></ul></li><li><strong>调用sayHello</strong>：<ul><li>在<code>sayHello</code>输入框中，<code>_id</code>填<code>1</code>；</li><li>点击<code>call</code>按钮，返回结果为<code>&quot;Hi Solidity!From HSL&#39;s contract.&quot;</code>；</li></ul></li><li><strong>测试未设置的id</strong>：<ul><li><code>sayHello</code>的<code>_id</code>填<code>2</code>，点击<code>call</code>，返回<code>&quot;Hello World!From HSL&#39;s contract.&quot;</code>（使用默认<code>strVar</code>）。</li></ul></li></ol><h2 id="七、新手常见问题与避坑指南"><a href="#七、新手常见问题与避坑指南" class="headerlink" title="七、新手常见问题与避坑指南"></a>七、新手常见问题与避坑指南</h2><ol><li><strong>编译器版本不兼容</strong>：若编译报错“string.concat not found”，说明编译器版本低于0.8.12，需升级版本或替换为<code>abi.encodePacked</code>。</li><li><strong>地址比较错误</strong>：不要用<code>infoMapping[_id].addr == 0</code>判断零地址，需用<code>infoMapping[_id].addr == address(0)</code>（Solidity不允许整数与地址直接比较）。</li><li><strong>存储位置混淆</strong>：若函数内定义<code>Info storage info</code>，会直接引用状态变量（可能意外修改数据），新手建议先熟悉<code>memory</code>的使用。</li><li><strong>gas消耗过高</strong>：避免在<code>view</code>&#x2F;<code>pure</code>函数内调用非<code>view</code>&#x2F;<code>pure</code>函数，否则会消耗gas；动态数组<code>push</code>过多元素也会导致gas溢出。</li></ol><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本节课通过<code>HelloWorld</code>合约，我们系统学习了Solidity的核心基础：</p><ul><li>合约头部声明（SPDX许可证、编译器版本）；</li><li>基础数据类型（bool、uint、int、bytes、string、address）；</li><li>复合数据类型（struct、array、mapping）；</li><li>函数设计（可见性、状态修饰符、全局变量<code>msg.sender</code>）；</li><li>存储位置（storage、memory、calldata）；</li><li>合约部署与测试（Remix实践）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思口语笔记分享</title>
      <link href="/2025/09/10/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/"/>
      <url>/2025/09/10/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="雅思口语"><a href="#雅思口语" class="headerlink" title="雅思口语"></a>雅思口语</h1><h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="三必考话题"><a href="#三必考话题" class="headerlink" title="三必考话题"></a>三必考话题</h2><p><strong>Do you work or study?</strong></p><p>I’m currently a sudent at GDUFE and majoring in software enginering. I’m actually a junior student this year, and maybe I will be a programmer in the future.</p><p><strong>Why did you choose this major?</strong></p><p>Well, actually, I wasn’t entirely sure at first, but after a few-days consideration, I realized that was the only major I can choose. I don’t want to be a liberal arts students. That doesn’t suit me. And I don’t want to be too tired like machine manufacturing. So be a programmer is the best choice for me.</p><p><strong>Is your major popular in China?</strong></p><p>Absolutely, </p><h2 id="Do-you-questions"><a href="#Do-you-questions" class="headerlink" title="Do-you questions"></a>Do-you questions</h2><h3 id="Do-you-like-love-art-（否定）"><a href="#Do-you-like-love-art-（否定）" class="headerlink" title="Do you like&#x2F;love art?（否定）"></a>Do you like&#x2F;love art?（否定）</h3><p>No, <strong>not a bit</strong>. I can’t understand or <strong>connect to</strong> art works like some people can. <strong>I guess</strong> my art <strong>taste eluded</strong> me when I was born, <strong>so</strong> I’m not <strong>good at</strong> or <strong>familiar with</strong> any <strong>art</strong> form. I <strong>do</strong> wish that I could <strong>have a good taste of</strong> art <strong>though.</strong> That must be great fun.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>not a bit</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>I guess&#x2F;think&#x2F;believe…; so….; do; though（放结尾表但是）</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>connect to; taste; elude; be good at; be familiar with; art form; have a good taste of</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>I can’t do sth (well) like&#x2F;as sb can&#x2F;I can do sth better than sb&#x2F;others; I wish that I could…（虚拟语气）; that&#x2F;it must be…</p><h3 id="Do-you-think-breakfast-is-important-（肯定）"><a href="#Do-you-think-breakfast-is-important-（肯定）" class="headerlink" title="Do you think breakfast is important?（肯定）"></a>Do you think breakfast is important?（肯定）</h3><p><strong>That’s for sure</strong>. <strong>At least</strong> it <strong>provides</strong> the energy we need for the morning. <strong>Not to mention</strong> the <strong>good</strong> <strong>mood</strong> it can bring. <strong>By the way</strong>, I almost never <strong>skip</strong> my breakfast. It’s my <strong>daily must</strong>.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>that’s for sure</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>by the way; not to mention</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>at least; provide; good mood; skip; daily must</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>at least…not to mention(that)…</p><p>（万能句）<strong>Not to mention</strong> the <strong>good</strong> <strong>mood</strong> it can bring.</p><h3 id="Do-you-often-read-books-（肯定）"><a href="#Do-you-often-read-books-（肯定）" class="headerlink" title="Do you often read books?（肯定）"></a>Do you often read books?（肯定）</h3><p><strong>No doubt about that.</strong> I read whenever I get the chance**.** I <strong>simply can’t get enough of</strong> reading. If it weren’t for them**,**  <strong>I guess</strong> my life would be boring <strong>in a sense</strong>. Whether it’s fiction, non-fiction, or even poetry, I always have a book with me even when I <strong>have a</strong> <strong>lot on my plate</strong> (Page 50). </p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>no doubt about that</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>simply; I guess; </p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>can’t get enough of; in a sense; explore new perspectives</p><p><em><strong>Idioms 习语</strong></em></p><p>have a lot on my plate很忙</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>If it weren’t for …, I guess .. would be ….; whether it’s A or B or C</p><p>（万能句）<strong>It’s a fantastic way to explore new perspectives.</strong></p><h3 id="Do-you-prefer-to-be-a-driver-or-a-passenger-（选择题）"><a href="#Do-you-prefer-to-be-a-driver-or-a-passenger-（选择题）" class="headerlink" title="Do you prefer to be a driver or a passenger?（选择题）"></a>Do you prefer to be a driver or a passenger?（选择题）</h3><p><strong>I much prefer being a driver.</strong> I love driving and I enjoy feeling <strong>in control of</strong> the vehicle and a better view of the road. <strong>On top of that</strong>, driving helps me <strong>stay on the ball</strong> (Page48); <strong>in contrast</strong> (Page 12), I find being a passenger in a car very boring.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>I much prefer sth&#x2F;doing sth</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>on top of that 除此之外; in contrast 对比</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>be&#x2F;feel&#x2F;stay in control of sth</p><p><em><strong>Idioms 习语</strong></em></p><p>be&#x2F;stay on the ball 非常专注</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>I find sth + adj.</p><h3 id="Do-you-often-send-emails-（否定）"><a href="#Do-you-often-send-emails-（否定）" class="headerlink" title="Do you often send emails?（否定）"></a>Do you often send emails?（否定）</h3><p><strong>I hardly ever use emails these days, to be honest.</strong> <strong>I mean</strong>, people prefer <strong>instant messaging apps</strong> like WeChat and What’s App, which I think (Page 56) are faster and more convenient for quick replies.  <strong>Perhaps</strong> they are still <strong>widely</strong> used <strong>for professional purposes</strong>, <strong>which means that</strong> (Page 56) I’d <strong>probably</strong> use them a lot after graduation. </p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>hardly ever these days</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>to be honest; I mean; perhaps; widely; probably</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>instant messaging apps; for professional purposes</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>which I think is&#x2F;are…; which means that…</p><h3 id="Do-you-like-being-busy-（模糊回答）"><a href="#Do-you-like-being-busy-（模糊回答）" class="headerlink" title="Do you like being busy?（模糊回答）"></a>Do you like being busy?（模糊回答）</h3><p><strong>It’s hard to say.</strong> <strong>I mean</strong>, I’d like to <strong>keep myself occupied from time to time</strong>, but not always. <strong>You</strong> <strong>know</strong>, I don’t want to be <strong>under the gun</strong> (Page 51) all the time. My <strong>motivation and passion</strong> will soon <strong>wear off</strong> (Page 46) if I go too long without relaxing properly.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>It’s hard to say</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>I mean; you know;</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>keep myself occupied; from time to time（有时）; motivation and passion; wear off（消逝，慢慢磨灭，多用于情感方面 耐心、爱、恨、热情、积极性）</p><p><em><strong>Idioms 习语</strong></em></p><p>under the gun</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>If I go too long without sth&#x2F;doing sth… 太久不干</p><h3 id="Do-you-think-travel-is-important-（肯定）"><a href="#Do-you-think-travel-is-important-（肯定）" class="headerlink" title="Do you think travel is important?（肯定）"></a>Do you think travel is important?（肯定）</h3><p>**It’s a one-hundred-percent YES!**I think it is <strong>vital</strong> in our life. It doesn’t just mean <strong>a few days of shutdown from</strong> your tiring, boring…or repeated…or whatever-you-call-it everyday life. It’s also about finding out what you really want, about… <strong>giving yourself some time to</strong> <strong>contemplate</strong> the things you haven’t had time to care about</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>It’s a one-hundred-percent YES!</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>&#x2F;</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>vital; a few days of shutdown from…; contemplate（仔细考虑）; give yourself some time&#x2F;space to do sth</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>It doesn’t just mean…It’s also about…;</p><h2 id="Did-you-questions"><a href="#Did-you-questions" class="headerlink" title="Did-you questions"></a>Did-you questions</h2><h3 id="Did-your-parents-teach-you-to-share-when-you-were-a-child"><a href="#Did-your-parents-teach-you-to-share-when-you-were-a-child" class="headerlink" title="Did your parents teach you to share when you were a child?"></a>Did your parents teach you to share when you were a child?</h3><p><strong>Wow(well&#x2F;uhm), this really takes some recall…I think… they did.</strong> I still <strong>vaguely remember</strong> that they sometimes would TELL me to share my snacks and toys with my <strong>peers</strong>. But what’s still <strong>vivid</strong> in my mind is that they themselves would share things to each other a lot and with other people <strong>as well</strong>. I guess that was how they ACTUALLY taught me.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>Wow(well&#x2F;uhm), this really takes some recall…I think…</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>vaguely; as well; actually</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>Peers（同龄人）; vivid</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>（非常好用）I still vaguely remember that…; what’s still vivid in my mind is that…</p><h3 id="Did-you-enjoy-traveling-by-car-when-you-were-a-kid"><a href="#Did-you-enjoy-traveling-by-car-when-you-were-a-kid" class="headerlink" title="Did you enjoy traveling by car when you were a kid?"></a>Did you enjoy traveling by car when you were a kid?</h3><p><strong>I can’t really remember</strong>, **but <strong>I think I did</strong>. I vaguely recall <strong>looking forward to</strong> (Page 45) road trips, because they often meant no school and having snacks along the way. <strong>Even though</strong> it’s a bit <strong>blurry</strong> now, I think car trips were <strong>probably</strong> fun and a part of my childhood I’d like to revisit someday.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>I can’t really remember, but I think&#x2F;guess…</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>even though&#x2F;probably</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>look forward to sth&#x2F;doing sth</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>I vaguely recall…; (because) they often mean&#x2F;meant…</p><h3 id="Did-you-use-coins-as-a-child"><a href="#Did-you-use-coins-as-a-child" class="headerlink" title="Did you use coins as a child?"></a>Did you use coins as a child?</h3><p><strong>Absolutely</strong>. <strong>In most cases</strong>, I would use coins for taking public transports, like, the bus or the metro&#x2F;subway&#x2F;tube. <strong>Every now and then</strong> I also got some <strong>pocket money</strong> from my parents for buying snacks, and it’s usually some coins they got as <strong>the change</strong>.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>Absolutely</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>In most cases; every now and then（有时候 &#x3D; sometimes）; like</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>pocket money（零花钱）; the change（零钱）</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>I would do sth; 可用来过去经常做某件事情</p><h2 id="Are-you-questions"><a href="#Are-you-questions" class="headerlink" title="Are-you questions"></a>Are-you questions</h2><h3 id="Are-you-interested-in-other’s-dream"><a href="#Are-you-interested-in-other’s-dream" class="headerlink" title="Are you interested in other’s dream?"></a>Are you interested in other’s dream?</h3><p><strong>I can’t say for sure. I guess it depends</strong>. If someone is sharing a dream revealing something about their thoughts or emotions, I do find it <strong>fascinating</strong>. <strong>However</strong>, if the dream is just a random mix of events, I might <strong>struggle to</strong> <strong>stay engaged</strong>. <strong>That said</strong>, I think dreams can be a window into how someone feels or what’s on their mind, so I will try to listen when <strong>it</strong> <strong>seems important to</strong> them.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>I can’t say for sure. I guess it depends.</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>that said; however; do</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>(find sth)fascinating; struggle to do sth; stay engaged</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>If…, I do….However, if…, I might…; it seems important to sb&#x2F;do</p><h3 id="Are-you-good-at-remembering-phone-numbers"><a href="#Are-you-good-at-remembering-phone-numbers" class="headerlink" title="Are you good at remembering phone numbers?"></a>Are you good at remembering phone numbers?</h3><p><strong>No, I’m quite terrible when it comes to remembering them.</strong> These <strong>random</strong> numbers just won’t <strong>fit into my head</strong> unless I repeat them for a hundred times. <strong>Besides</strong>, cell phone numbers in China are 11 digits…which makes it even harder.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>No, I’m quite terrible when it comes to…&#x2F;Yes, I’m super good when it comes to sth.</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>unless; besides</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>Random; fit into my head（融入进我的脑袋）</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>…which makes it even harder&#x2F;better&#x2F;easier…</p><h2 id="Have-you-questions"><a href="#Have-you-questions" class="headerlink" title="Have-you questions"></a>Have-you questions</h2><h3 id="Have-you-ever-seen-some-old-buildings-in-the-city"><a href="#Have-you-ever-seen-some-old-buildings-in-the-city" class="headerlink" title="Have you ever seen some old buildings in the city?"></a>Have you ever seen some old buildings in the city?</h3><p> <strong>I have indeed</strong>. One of the most <strong>memorable</strong> experiences I’ve had is <strong>stumbling upon</strong> an ancient temple. I <strong>spent</strong> the whole afternoon <strong>exploring</strong> this <strong>one-of-a-kind</strong> structure. When I <strong>look back on</strong>(Page 44) that visit, it <strong>always reminds me of</strong> how life used to be decades ago. </p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>I have indeed.（我确实有）</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>always</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>explore; stumble upon&#x2F;run into&#x2F;come across; look back on sth（回忆，回看）; remind sb of…（让某人想起）</p><p><em><strong>Idioms 习语</strong></em></p><p>One-of-a-kind（独特的）</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>One of the most memorable experiences I’ve had is (doing sth)… </p><h2 id="What：列举类问题"><a href="#What：列举类问题" class="headerlink" title="What：列举类问题"></a>What：列举类问题</h2><h3 id="what-kind-of-websites-are-popular-in-your-country"><a href="#what-kind-of-websites-are-popular-in-your-country" class="headerlink" title="what kind of websites are popular in your country?"></a>what kind of websites are popular in your country?</h3><p>Well, there are <strong>various kinds of well-liked</strong> website in China. There’s no doubt that social networking sites are the most popular ones like TikTok. It has largely <strong>transformed</strong> the social media <strong>landscape</strong> over the last decade. <strong>Another one comes to mind is</strong> shopping sites like Taobao and Jingdong, which are <strong>all the rage</strong>, too.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>There are various kinds of…</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>Another one comes to mind is…</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>well-liked; transform the … landscape（在…行业掀起翻天覆地变化）</p><p><em><strong>Idioms 习语</strong></em></p><p>all the rage（风靡一时）</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>There’s no doubt that…</p><h3 id="What-kind-of-advertising-do-you-like"><a href="#What-kind-of-advertising-do-you-like" class="headerlink" title="What kind of advertising do you like?"></a>What kind of advertising do you like?</h3><p>Well, I’m into <strong>all sorts of</strong> ads. If I had to (Page 62) pick one**,** I would say ads that keep it simple and funny are my favorite. If they <strong>manage</strong> <strong>to</strong> tell a good story or make me laugh, I’m <strong>all for it</strong>. No need for anything too <strong>fancy</strong> or too <strong>complicated</strong> <strong>–</strong> just something that feels <strong>genuine</strong> and entertaining.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>I’m into&#x2F; there are all sorts of…</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>&#x2F;</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>manage to; fancy（花哨的，时髦的）; genuine（真诚，真实）; complicated</p><p><em><strong>Idioms 习语</strong></em></p><p>all for it（全面赞成）</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>If I had to…I would say…; No need for anything…just something…</p><h3 id="What-do-you-do-when-you-feel-bored"><a href="#What-do-you-do-when-you-feel-bored" class="headerlink" title="What do you do when you feel bored?"></a>What do you do when you feel bored?</h3><p>Well, I guess there are <strong>a bunch of</strong> stuff I can do. No matter when (Page57) I feel dull, I’d find something to <strong>keep me occupied</strong> or <strong>bring me</strong> <strong>pleasure</strong>, <strong>like</strong> planning my next vacation, <strong>catching up on</strong> reading and watching TV shows to get some inspiration <strong>or just going for a stroll</strong> to get some fresh air.</p><p><em><strong>Yes&#x2F;No highlights 是否类问题首句亮点</strong></em></p><p>a bunch of…（多）</p><p><em><strong>DM&amp;C&amp;ADV 语篇标记词&#x2F;逻辑连接词&#x2F;副词</strong></em></p><p>like; or just</p><p><em><strong>Words&#x2F;Phrases 词汇&#x2F;短语</strong></em></p><p>catch up on（追赶进度）; go for a stroll &#x3D; take a stroll（散步）; keep me occupied; bring me pleasure</p><p><em><strong>Idioms 习语</strong></em></p><p>&#x2F;</p><p><em><strong>Sentence forms 句子结构</strong></em></p><p>No matter when…I’d…（每当…)</p><h1 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><h2 id="事件类话题"><a href="#事件类话题" class="headerlink" title="事件类话题"></a>事件类话题</h2><h3 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h3><ol><li><p>事件背景建立</p><p>When it happened</p><p>Where you were</p><p>When and where the party was held</p></li><li><p>参与者</p><p>Who helped you</p><p>Who you help</p><p>Who attended the event</p></li><li><p>事件过程</p><p>What you did</p><p>How you helped</p><p>Why you did</p></li><li><p>反应与感受</p><p>How you responded</p><p>How you felt</p><p>And explain why is was successful</p></li></ol><h3 id="首句"><a href="#首句" class="headerlink" title="首句"></a>首句</h3><p><strong>固定句子开头</strong>I’d like to describe</p><p><em><strong>简洁明了，将不明确的变明确</strong></em></p><p>Describe a time when someone asked for your opinion.</p><p>&#x3D;&gt; I’d like to describe a time when my classmates asked for my opinion about the question in the exam.</p><h3 id="事件背景建立"><a href="#事件背景建立" class="headerlink" title="事件背景建立"></a>事件背景建立</h3><p><strong>时间</strong> It happened&#x2F;took place <strong>(1.大概时间)</strong> when <strong>(2.时间框架下的小细节)</strong></p><p><strong>地点</strong> I was <strong>(3.具体动作+地点)</strong>, which is <strong>(4.</strong> <strong>地点的作用或特点)</strong></p><ol><li><p>大概时间示例</p><p>recently; not long ago; a while back; during my childhood; on a warm summer evening; When I was younger…</p></li><li><p>小细节示例</p><p>everything was perfect for…; the weather was suitable for outdoor&#x2F;indoor activities; I was in the mood for…</p></li><li><p>具体地点示例</p><p>waiting for my friend at a bustling market; sipping coffee in a cafe; listening to music in a quiet corner at the park; <strong>mooching around</strong>（动来动去） at a shopping mall…</p></li><li><p>作用或特点示例</p><p>A perfect <strong>hide-out</strong>（掩体，避难所） for <em><strong>escaping my busy schedules&#x2F;enjoying my laid-back time</strong></em>…; the most visited place in our neighborhood; my <strong>go-to</strong>（首选的，常用的） place for…</p></li></ol><h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p><strong>描述方向转换句</strong> Speaking of <strong>(抄描述方向提示词)</strong></p><p><strong>具体人物细节</strong> Well, my <strong>(5.具体人物)</strong> was&#x2F;were there with me. By the way, he&#x2F;she is &#x2F;they are in their <strong>(6.模糊年纪)</strong> who is&#x2F;are always <strong>(7.基本人物特征)</strong></p><ol start="5"><li><p>具体人物示例</p><p>parents&#x2F;best friends&#x2F;brother&#x2F;sister&#x2F;teacher…</p></li><li><p>年纪示例</p><p>Be in one’s early&#x2F;mid&#x2F;late 20s&#x2F;30s&#x2F;40s&#x2F;50s&#x2F;60s…</p></li><li><p>基本人物特征示例</p><p>easy-going&#x2F;open-minded&#x2F;energetic&#x2F;curious（好奇的）&#x2F;eager to learn new things&#x2F;ready to help others</p></li></ol><h3 id="事件过程"><a href="#事件过程" class="headerlink" title="事件过程"></a>事件过程</h3><p><strong>描述方向转换句</strong> As for <strong>(抄描述方向提示词)</strong> </p><p><strong>人物做了什么</strong>What’s still fresh in my mind is that <strong>(5.具体人物)+(8.动作泛描述)</strong></p><p><strong>为什么</strong> As&#x2F;because&#x2F;since&#x2F;for the reason that&#x2F;based on the fact that <strong>(9.具体原因)</strong></p><p><strong>怎么做的</strong> To be more specific, <strong>(5.具体人物)+(10.动作具体描述1)</strong>. Furthermore, <strong>(5.具体人物)+(10.动作具体描述2)…</strong></p><ol start="8"><li><p>动作泛描述示例</p><p>took charge of sth&#x2F;made great contributions to sth&#x2F;offered some suggestions about…</p></li><li><p>具体原因示例</p><p>被动（为什么是ta不是别人）：sb+be+ the most experienced among all; sb+be+an expert in…; </p><p>主观（ta为什么想做这事）：sb wants&#x2F;needs&#x2F;aspires to（渴望做）…</p></li><li><p>动作具体描述示例</p><p>记流水账，拆开细节讲</p></li></ol><h3 id="反应与感受"><a href="#反应与感受" class="headerlink" title="反应与感受"></a>反应与感受</h3><p><strong>描述方向转换句</strong> Turning to <strong>(抄描述方向提示词)</strong></p><p><strong>人物反应</strong> <strong>(5.具体人物) + (11.反应泛描述)</strong></p><p><strong>我的感受</strong> Based on this experience, I felt <strong>(12.泛感受)</strong>, as you may know&#x2F;you know&#x2F;you see, <strong>(13.泛感受产生的基础)</strong>, which is why I wish that <strong>(14.将来的展望)</strong></p><ol start="11"><li><p>反应泛描述示例</p><p>情绪（副+形） be+a little&#x2F;somehow&#x2F;really&#x2F;seriously + delighted&#x2F;surprised&#x2F;worried…; </p><p>动作 followed sb’s advice; rejected sb’s proposal; didn’t show much interest towards…</p></li><li><p>泛感受示例</p><p>a little&#x2F;somehow&#x2F;really&#x2F;seriously + surprised&#x2F;shocked&#x2F;fascinated&#x2F;attracted&#x2F;worried&#x2F;tired&#x2F;exhausted&#x2F;angry…;</p></li><li><p>泛感受的基础</p><p>I made a terrible mistake by…; I never thought that sth could make such a huge influence on…; we spent some real quality time together with…</p></li><li><p>展望示例</p><p>we could have more time to be spent together in the future&#x2F; I would never need to worry about it in the future&#x2F; they would have more understanding of…</p></li></ol><h3 id="好用句子"><a href="#好用句子" class="headerlink" title="好用句子"></a>好用句子</h3><p>It was a family reunion, so all the familiar faces were there—my parents, my siblings, and a few close relatives. It was one of those rare moments when everyone could make time to gather in one place.</p><h2 id="事物类话题"><a href="#事物类话题" class="headerlink" title="事物类话题"></a>事物类话题</h2><h3 id="共性-1"><a href="#共性-1" class="headerlink" title="共性"></a>共性</h3><ol><li>事物简介</li><li>事物细节</li><li>事物交互体验</li></ol><h3 id="首句-1"><a href="#首句-1" class="headerlink" title="首句"></a>首句</h3><p><strong>固定句子开头</strong> I’d like to describe…</p><h3 id="事物简介"><a href="#事物简介" class="headerlink" title="事物简介"></a>事物简介</h3><p><strong>时间</strong> If my memory serves me right, I got it <strong>(1.大概时间)</strong> when <strong>(15.时间框架下事件描述)</strong></p><p><strong>人物</strong> In fact, <strong>(5.具体人物)</strong> bought&#x2F;gave it to me as <strong>(16.东西的作用)</strong></p><p><strong>事物基本特征</strong> ,which was <strong>(17.事物基本特征)</strong> and&#x2F;but <strong>(18.附加价值)</strong></p><ol start="15"><li><p>时间框架下事件描述</p><p>I was having my 18th birthday; I was preparing for my final; my family were spending our  Chinese new year; my friends and I were on vacation…</p></li><li><p>东西的作用</p><p>a birthday gift; graduation gift; a token of our friendship; comfort to my bad mood; a reward to my good performance in…</p></li><li><p>事物基本特征</p><p>not an expensive item; something not easy to come by; something I’ve been longing for; an exquisite gift…；</p></li><li><p>附加价值</p><p>full of love&#x2F;effort&#x2F;good wishes…</p></li></ol><h3 id="事物细节"><a href="#事物细节" class="headerlink" title="事物细节"></a>事物细节</h3><p><strong>描述方向转换句</strong> <strong>Speaking of (抄描述方向提示词)</strong></p><p><strong>事物具体特征</strong> Well, what’s most impressive about it is that <strong>(19.事物具体特征1)</strong>. Besides, it’s also worth mentioning that <strong>(19.事物具体特征2)</strong></p><ol start="19"><li><p>事物具体特征</p><p><strong>Color</strong>: gray; brown; teal（青色）; transparent; maroon（深红棕色）; purple; -ish; (It has a … color)（像什么一样的颜色） … </p><p><strong>Material</strong>: metal; plastic; alloy（合金）; aluminum（铝）; carbon fibre; nylon; cotton（棉花）; polyester（聚酯纤维）; (It’s made of…; <strong>It is designed with eco-friendly and sustainable materials</strong>) … </p><p><strong>Shape</strong>: square（正方形）; rectangle（长方形）; triangle（三角形）; cone（锥体）; cylinder（柱体）; pyramid （四棱锥）(It has a …. shape) … </p><p><strong>Function</strong>: it is equipped with cutting-edge（前沿） technology in terms of…; it is made to provide ultimate convenience in terms of; it is a sheer embodiment of（有象征的）; … chips</p><p><strong>Other details</strong>: patterns; chip 芯片; processor 处理器</p></li></ol><h3 id="事物交互体验"><a href="#事物交互体验" class="headerlink" title="事物交互体验"></a>事物交互体验</h3><p><strong>描述方向转换句</strong> As for (抄描述方向提示词)</p><p><strong>事物重要性</strong> I have to say that it’s really (<strong>20. 重要性描述</strong>)</p><p><strong>为什么</strong> As&#x2F;because&#x2F;since&#x2F;for the reason that&#x2F;based on the fact that (<strong>21.事物重要性的原因-需细节</strong>)</p><p><strong>对未来的期许</strong> Based on my experience, I wish that (<strong>14.将来的展望</strong>)</p><ol start="20"><li><p><strong>重要性描述</strong> </p><p>useful and I rely on it to stay productive and efficient; not very user-friendly; </p><p>an indispensable part of my daily routine; a savior to…</p></li><li><p><strong>事物重要性的原因</strong></p><p>It’s easy to handle, even for long durations. For instance, … </p><p>It encourages respect for traditional values. For example, … </p><p>It saves a huge amount of time for housework, you know, …</p></li><li><p><strong>将来的展望</strong> </p><p>I could create more memories with it…; it becomes a symbol of cultural pride…; </p><p>It wears out&#x2F;off slowly so that it can last for longer duration…;</p></li></ol><h2 id="人物类话题"><a href="#人物类话题" class="headerlink" title="人物类话题"></a>人物类话题</h2><h3 id="共性-2"><a href="#共性-2" class="headerlink" title="共性"></a>共性</h3><ol><li>人物简介</li><li>人物特征</li><li>他与你&#x2F;其他人的交互</li><li>反应与感受</li></ol><h3 id="首句-2"><a href="#首句-2" class="headerlink" title="首句"></a>首句</h3><p><strong>固定句子开头</strong> I’d like to describe <em>a person</em>(具体) (called)…</p><p><strong>看题目进行改写</strong></p><p>​Describe someone you really like to spend time with </p><p>​Describe a person who contributes to the society </p><p>​Describe a popular&#x2F;well-known person in your country </p><p>​Describe a friend you like to talk with </p><p>​Describe a person who you follow on social media </p><p>​Describe a family member who you want to work with in the future</p><h3 id="人物简介"><a href="#人物简介" class="headerlink" title="人物简介"></a>人物简介</h3><p><strong>模糊人物特征</strong> , a <strong>(22.人物社会状态) (23.职业)</strong> who is in his&#x2F;her early&#x2F;mid&#x2F;late 20s&#x2F;30s&#x2F;40s…</p><p><strong>如何相识</strong> I first came to know him&#x2F;her <strong>(1.大概时间) (15.时间框架下事件描述) (24.具体地点)</strong>. We started to have connections(He&#x2F;she left me a deep impression) as&#x2F;because&#x2F;since&#x2F;for the reason that&#x2F;based on the fact that (9.具体原因) </p><ol start="22"><li><p><strong>人物社会状态</strong></p><p>学生：popular&#x2F;well-liked&#x2F;hard-working&#x2F;excellent&#x2F;top… </p><p>社会人士：Retired&#x2F;renowned&#x2F;famous&#x2F;popular&#x2F;well-liked&#x2F;prestigious（有声望的）&#x2F;respected&#x2F;beloved（受爱戴的）&#x2F;highly attained（高成就的）…</p></li><li><p><strong>职业</strong> </p><p>musician; medical expert; movie star; singer; entrepreneur…</p></li><li><p><strong>具体地点</strong> </p><p>at the community center; at the workplace; in the school auditorium…</p></li><li><p><strong>具体原因</strong></p><p>(身边人)We share common interests in…; we often have common topics about…; we speak the same language in terms of…, I mean&#x2F;you know…; （名人）简单讲讲这个人的吸引点</p></li></ol><h3 id="人物特征"><a href="#人物特征" class="headerlink" title="人物特征"></a>人物特征</h3><p><strong>描述方向转换句</strong> **Speaking of **(抄描述方向提示词…)</p><p><strong>具体人物特征</strong> <em><strong>Above all else</strong></em>, I have to say that he&#x2F;she is really&#x2F;seriously&#x2F;truly&#x2F;indeed… <strong>(25.具体人物特征)</strong> + as&#x2F;because&#x2F;since&#x2F;for the reason that&#x2F;based on the fact that <strong>(9.具体原因-需细节)</strong></p><ol start="25"><li><p><strong>具体人物特征</strong> </p><p>skilled&#x2F;professional&#x2F;remarkable&#x2F;exceptional&#x2F;out of the ordinary&#x2F;a hidden gem（沧海遗珠）&#x2F;genius&#x2F;lowprofile&#x2F;typical introvert（内向的）&#x2F;extrovert（外向的）&#x2F;meticulous（一丝不苟的）&#x2F;considerate&#x2F;enterprising（有事业心，有魄力的）&#x2F;ambitious…</p></li><li><p><strong>具体原因</strong></p><p>she&#x2F;he always lends a helping hand in times of need…; (kind, friendly, warmheated)</p><p>she&#x2F;he <strong>took the initiative（主动性）to</strong> lead a multitude（大量的）of challenging projects…; (enterprising, hard-working, ambitious)</p><p>she&#x2F;he was never intimidated（吓到） by the setbacks（挫折） in her&#x2F;his life… (brave)</p><p>she&#x2F;he never shows off even when she&#x2F;he has achieved huge success… (lowprofile, low-key)</p><p>she&#x2F;he <strong>never ceased（停止） to</strong> strive for an extra inch in her study&#x2F;work…(enterprising, hard-working, ambitious)</p></li></ol><h3 id="Ta与你-其他人的交互"><a href="#Ta与你-其他人的交互" class="headerlink" title="Ta与你&#x2F;其他人的交互"></a>Ta与你&#x2F;其他人的交互</h3><p><strong>描述方向转换句</strong> <strong>As for (抄描述方向提示词)</strong> </p><p><strong>人物做了什么</strong> <strong>What’s still fresh in my mind is that</strong> (5.具体人物)+(8.动作泛描述)</p><p><strong>怎么做的</strong> <strong>To be more specific,</strong> (5.具体人物)+(10.动作具体描述1)<strong>. Furthermore&#x2F;In addition,</strong> (5.具体人物)+(10.动作具体描述2)<strong>…</strong></p><h3 id="反应与感受-1"><a href="#反应与感受-1" class="headerlink" title="反应与感受"></a>反应与感受</h3><p><strong>描述方向转换句</strong> <strong>Turning to (抄描述方向提示词)</strong></p><p><strong>我的感受</strong> <strong>(12.泛感受)</strong>, as you may know&#x2F;you know&#x2F;you see, <strong>(13.泛感受产生的基础)</strong>, which is why I wish that <strong>(14.将来的展望)</strong></p><ol start="12"><li><p><strong>泛感受</strong></p><p>I <strong>felt deeply inspired by</strong> (his&#x2F;her determination and strong work ethic（职业道德）); </p><p>I couldn’t help but feel (immense gratitude(adj. grateful) for his&#x2F;her unwavering（不动摇的）support);  &#x3D; thank sb. for sth.</p><p>I felt a deep sense of (respect for their selflessness and dedication); </p></li><li><p><strong>将来的展望</strong></p><p><strong>We could build stronger connections&#x2F;ties&#x2F;bond</strong> together in the future… </p><p>We could <strong>collaborate</strong> further in more projects in the future… </p><p>I could gain more <strong>insights</strong>（深刻见解）from working with him&#x2F;her in the future… </p><p>I could meet her&#x2F;him in person as soon as possible…</p></li></ol><h2 id="地点类话题"><a href="#地点类话题" class="headerlink" title="地点类话题"></a>地点类话题</h2><h3 id="共性-3"><a href="#共性-3" class="headerlink" title="共性"></a>共性</h3><ol><li>地点简介</li><li>地点特征</li><li>个人体验</li><li>反应与感受</li></ol><h3 id="首句-3"><a href="#首句-3" class="headerlink" title="首句"></a>首句</h3><p><strong>固定句子开头 I’d like to describe a place called</strong></p><p><strong>看题目进行改写</strong></p><p>​Describe a quiet place you like to go </p><p>​Describe a public park or garden </p><p>​Describe a countryside that you have been to </p><p>​Describe a time you visited a new place </p><p>​Describe a place (city&#x2F;town) that is good for people to live in </p><p>​Describe an indoor or outdoor place where it is easy for you to study</p><h3 id="地点简介"><a href="#地点简介" class="headerlink" title="地点简介"></a>地点简介</h3><p><strong>在哪</strong> , which is located&#x2F;situated in&#x2F;at&#x2F;to&#x2F;on (<strong>26.具体方位</strong>), a place known for (<strong>27.典型特征</strong>).</p><p>in:在某一较大范围的内部at:表示 “在某一具体、小型的‘点式’位置”to:表示 “在某一范围的‘外部’，且不相邻”on:表示 “在某一范围的‘外部且相邻’” 或 “在某一表面上”</p><p><strong>如何知道</strong> If I’m not mistaken, I first came to know about this place (<strong>1.大概时间</strong>) when (<strong>15.时间框架下的事件描述</strong>).</p><ol start="26"><li><p><strong>具体方位</strong> </p><p>the south of China; the heart of the city; busy streets of Beijing; a hidden&#x2F; quiet corner of the town; the most visited area of downtown; …</p></li><li><p><strong>典型特征</strong></p><p>tourism; urbanization; robust economy; humanistic atmosphere; rich traditional culture; beautiful landscape; one-of-a kind architectures; unique design and extraordinary layout; top-notch&#x2F;decent service; …</p></li></ol><h3 id="地点特征"><a href="#地点特征" class="headerlink" title="地点特征"></a>地点特征</h3><p><strong>描述方向转换句</strong> Speaking of (抄描述方向提示词…)</p><p><strong>物理特征</strong> It’s a&#x2F;an (<strong>28.地点大小描述</strong>), surrounded by&#x2F;full of (<strong>29.自然或人工特征</strong>).</p><p><strong>氛围</strong> What’s even better is that the atmosphere here&#x2F;there is very&#x2F;really&#x2F; truly&#x2F;incredibly… (<strong>30.整体氛围描述</strong>).</p><ol start="28"><li><p><strong>地点大小描述</strong> </p><p>a mega city with a population of…; medium-sized town with a population of…;利用比较：a massive park as big as (five football fields)…; a tiny garden only the size of (my bedroom)…; </p></li><li><p><strong>自然或人工特征</strong> towering trees&#x2F;buildings; <strong>skyscrapers</strong>; modern architectures; <strong>picturesque scenery</strong>; <strong>otherworldly</strong> environment&#x2F;surroundings; unique design and extraordinary layout;</p></li><li><p><strong>整体氛围描述</strong> </p><p>prosperous and upbeat; lively and spirited; peaceful and calming; grand and splendid; solemn and divine;</p></li></ol><h3 id="个人体验"><a href="#个人体验" class="headerlink" title="个人体验"></a>个人体验</h3><p><strong>描述方向转换句</strong> As for (抄描述方向提示词)</p><p><strong>与地点的交互</strong> Whenever&#x2F;when I visit, I usually&#x2F;typically&#x2F;sometimes&#x2F;just… (<strong>8.</strong> <strong>动作泛描述</strong>), and my most memorable&#x2F;unforgettable experience there was (<strong>15.</strong> <strong>事件描述-需细节</strong>)</p><p><strong>频率</strong> That’s also the reason why I go there (<strong>31.</strong> <strong>拜访频率</strong>), often&#x2F;sometimes accompanied by (<strong>5.</strong> <strong>具体人物</strong>)</p><ol start="8"><li><p><strong>动作泛描述</strong></p><p>went to some tourist attractions; took a city tour; tried out all sorts of local cuisine; visited </p><p>all local museums; enjoyed the beautiful scenery&#x2F;most tourist attractions in the local </p><p>area; wandered in the town&#x2F;park…</p></li><li><p><strong>拜访频率</strong> </p><p><strong>regularly, like..every week; not quite regularly, but whenever I’m free; whenever I’m in the</strong> </p><p><strong>mood for it;</strong></p></li></ol><h3 id="反应与感受-2"><a href="#反应与感受-2" class="headerlink" title="反应与感受"></a>反应与感受</h3><p>**描述方向转换句 **Turning to (抄描述方向提示词)</p><p><strong>我的感受</strong> Personally, I find this place (<strong>12.</strong> <strong>泛感受</strong>) </p><p><strong>展望</strong> Looking ahead, I plan to revisit it at my nearest convenience&#x2F;explore more of it in the </p><p>near future, and I highly recommend it to anyone who (<strong>32.推荐理由</strong>).</p><ol start="12"><li><p><strong>泛感受</strong> </p><p>fascinating; like home; like a paradise; otherworldly; beyond imagination; </p></li><li><p><strong>推荐理由</strong></p><p>seeks peace and quiet; asks for some comfort from nature; wants to have a peek of&#x2F;catch a glimpse of（一瞥） what future looks like; would love to be shrouded（萦绕） by the vibe（氛围感受） of antiquity（古老）; cherishes the company of the wilderness; enjoys bathing in passion and motion;</p></li></ol><h1 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h1><p>在Part 2的基础上进行更深入的提问。与Part 1不同的是，Part 1更多的是对你个人进行提问，而Part 3提问的是社会的、普遍的情况。</p><h2 id="General-structure"><a href="#General-structure" class="headerlink" title="General structure"></a>General structure</h2><ul><li><p>Direct answer(1 sentence)</p><p>直接回应包含你的立场以及你的陈述重点</p><ul><li><p>Paraphrase for the answer(1-2 sentence) 改述</p><p>考虑一下说的内容是不是会有误解的可能性，是不是有点抽象，如果是，请记得主动改述，换个通俗易懂的方式说一遍(I mean…&#x2F;what mean is…&#x2F;In other words…&#x2F;To put it in another way…)</p></li></ul></li><li><p>Reason(why)&#x2F;Detail(how, how often, what, when) (1 - 2 sentence)</p><p>(For the reason that…&#x2F;This is because…&#x2F;Based on the fact that…&#x2F;I’ll try to explain this to you…)</p><ul><li><p>Example(1-2 sentences)</p><p>(For example&#x2F;instance&#x2F;Let me give you an example)</p></li><li><p>Conclusion(1 sentence)</p></li></ul></li></ul><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><p>stern（严厉的）</p><p>It is hard to generalize 这很难一概而论</p><p>it varies from person to person 这是因人而异的</p>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雅思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思写作笔记分享</title>
      <link href="/2025/08/14/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/"/>
      <url>/2025/08/14/%E9%9B%85%E6%80%9D%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="雅思写作"><a href="#雅思写作" class="headerlink" title="雅思写作"></a>雅思写作</h1><h2 id="小作文"><a href="#小作文" class="headerlink" title="小作文"></a>小作文</h2><p>图表 15-20min 大于150词</p><p>90%数据图（柱、饼、线、表） 8%地图、2%流程图</p><h3 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h3><ol><li><p>确定是静态图还是动态图，区别就为是否有时间上的变化</p></li><li><p>确定指标和维度</p><p><strong>指标</strong>为题目关心的量、研究的量，往往出现在题目首句宾语及图表标题</p><p><strong>维度</strong>为对指标进行分类的标签，例如国家、性别、指标的分类等等 <strong>维度可以帮助分段</strong></p></li><li><p>确定分段依据，开头段，主体段（2-3段），结尾段</p></li></ol><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ul><li>需要突出对比性，若是分段之后，一段内对比的内容重复或者不具有可比性则不行</li><li>动态图不可以按<strong>时间点</strong>分段，否则不能体现趋势</li><li>若动态图<strong>时间点</strong>大于等于三个，或许可以按<strong>时间段</strong>分段，时间点1到时间点2为一段，时间点2到时间点3为一段</li></ul><h3 id="开头段"><a href="#开头段" class="headerlink" title="开头段"></a>开头段</h3><p><strong>1分钟，利用同义替换用一句话改写题目首句</strong></p><h4 id="最常用替换"><a href="#最常用替换" class="headerlink" title="最常用替换"></a>最常用替换</h4><p><strong>记得去掉below</strong></p><ul><li>graph &#x3D; line graph 线图</li><li>chart &#x3D; <ul><li>bar chart 柱状图</li><li>pie chart 饼图</li></ul></li><li>table 表格</li><li>percentage &#x3D; proportion &#x3D; share</li><li>组成：make up &#x3D; constitute</li></ul><p><strong>用一般现在时（这与图表自身时态无关）</strong></p><ul><li>show&#x2F;illustrate&#x2F;compare&#x2F;depict…</li><li>give&#x2F;provide + information&#x2F;data + about</li></ul><p><strong>宾语（指标）如果不确定，就不要替换指标，直接照抄</strong></p><p><strong>定语（所有维度）题目概况你就具体，题目具体你就概括</strong></p><h4 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h4><p><em><strong>The chart below shows the total number of minutes (in billions) of telephone calls in the UK, divided into three categories from 1995 to 2002.</strong></em></p><p>&#x3D;&gt; The bar chart illustrates how many minutes were spent on telephone calls of three types in the UK, over a period of 7 years.</p><p>chart &#x3D; bar chart; show &#x3D; illustrate; category &#x3D; type; 1995-2002 &#x3D; over a period of 7 years; 改用how many句式</p><p><em><strong>The graph compares the rate of smoking in men and women in some land between the years 1960 and 2000</strong></em></p><p>&#x3D;&gt; The line graph shows the number of female and male smokers per 1000 people in some land over a period of 40 years.</p><p>graph &#x3D; line graph; compare &#x3D; show; the rate of &#x3D; the number of…per 1000 people; between 1960 and 2000 &#x3D; over a period of 40 years; men, women &#x3D; male, female</p><p><em><strong>The table below gives information on consumer spending on different items in five different countries in 2002.</strong></em></p><p>&#x3D;&gt; The chart illustrates&#x2F;shows the proportion of national&#x2F;domestic consumer spending of three categories&#x2F;types in different countries in 2002.</p><p>give &#x3D; show &#x3D; illustrate; information &#x3D; proportion &#x3D; percentage(当数据为百分比时); country &#x3D; domestic &#x3D; national</p><p><em><strong>The table below shows the amount of leisure time enjoyed by men and women of different employment status in March,2002.</strong></em></p><p>&#x3D;&gt; The bar chart illustrates how much leisure&#x2F;entertainment&#x2F;spare time was enjoyed&#x2F;spent by two genders&#x2F;males and females of five different employment status in March, 2002.</p><p>leisure &#x3D; entertainment &#x3D; spare time; enjoy &#x3D; spend;</p><p><em><strong>The three pie charts below show the change in annual spending by a particular UK school in 1981,1991 and 2001</strong></em></p><p>&#x3D;&gt; The three pie charts depict the changes in annual expenditures of a specific UK school for the years 1981, 1991, and 2001.</p><p>show &#x3D; depict; spending &#x3D; expenditure; particular &#x3D; specific</p><p><em><strong>The table shows the percentages of smartphone owners utilizing different features of their devices.</strong></em></p><p>&#x3D;&gt; the graph illustrates the proportions of people with smartphone utilizing seven different function of their devices</p><p>feature &#x3D; function; smartphone owner &#x3D; people with smartphone</p><h3 id="总结段"><a href="#总结段" class="headerlink" title="总结段"></a>总结段</h3><p>2～5 分钟，用 2 句话写出图表最显眼的两个<strong>特征</strong></p><p>如一直&#x2F;大部分时候都 <strong>最高&#x2F;最低&#x2F;增加&#x2F;减少</strong> 的东西</p><p><strong>不能写进总结段</strong>：数字&#x2F;原因&#x2F;建议&#x2F;预测</p><h4 id="例句-1"><a href="#例句-1" class="headerlink" title="例句"></a>例句</h4><p><em><strong>突出特点1:</strong> 总体而言，尽管监禁数据有所波动，但在大部分时间里，美国有着最大的监狱人口。</em></p><p>&#x3D;&gt; Overall, despite fluctuations in imprisonment figures, for most of the time, the United States had the largest prison population.</p><p>波动：fluctuations</p><p><em><strong>突出特点2:</strong> 此外，英国是唯一一个在此期间看到囚犯人数持续上升的国家。</em></p><p>&#x3D;&gt; Besides, the UK was the only country which&#x2F;that saw a sustained&#x2F;continuous&#x2F;continual&#x2F;constant increase in the number of prisoners during this period.</p><p><em><strong>总的来说，大部分功能变得越来越常用。其次，打电话是最常用widely used&#x2F;最广泛widespread&#x2F;最普及的功能</strong></em></p><p>&#x3D;&gt; Overall, most of these function became&#x2F;had become more and more widely used. Besides, making calls was always&#x2F;had been the most widespread function.</p><p><em><strong>总体而言，大多数学生至少能说一门非英语的外语。此外，西班牙语是最流行的第二语言。</strong></em></p><p>&#x3D;&gt; Overall, most of&#x2F;the majority of the students can speak at least one non-English language. Furthermore, Spanish is the most popular second language.</p><p><em><strong>总的来说，英国典型家庭在冬天的用电量大约是夏季的两倍。此外，大部分的电被用于暖屋子和烧热水</strong></em></p><p>&#x3D;&gt; Overall, the amount of electricity consumption of&#x2F;electricity consumed by a typical English home in winter is twice that in summer, Furthermore, most electricity is used for heating rooms and water </p><p><em><strong>总体而言，大部分图书馆会员都是18-64岁。此外，最受欢迎借阅类型是小说。此外尽管存在小幅度波动，但在此期间，图书馆会员的借阅数量呈上升趋势。</strong></em></p><p>&#x3D;&gt; Overall, most library members were aged between 18 and 64 years old. Beside, the most popular type of loans was fiction. It is noticeable that the total number of loans showed an upward trend despite small fluctuations.</p><p><em><strong>总体而言，私人工作室是年轻人学习舞蹈的主要地点。此外，第二张图显示，两种舞蹈（芭蕾舞和现代舞）的偏好与年龄相关</strong></em></p><p>&#x3D;&gt; Overall, private studios are the main location where young people learn to dance. Besides, the second chart shows that preferences for the two dance types (ballet and modern) are related to age.</p><p><em><strong>公路是英国最主要的货物运输方式，总体而言</strong></em></p><p>&#x3D;&gt; Road was the main means of goods transportation. Generally speaking, the amount of goods were</p><p><em><strong>总体而言，在给定的时间段内，纽约市的人口激增。此外，人口从曼哈顿分散到了其他行政区</strong></em></p><p>&#x3D;&gt; Overall, in the given period of time, the population in New York city exploded. Besides, the population in Manhattan moved&#x2F;scattered to other districts.</p><p>surge &#x3D; explode 激增; scatter &#x3D; decentralized分散</p><p><em><strong>总体而言，英国的本科生和研究生毕业后更倾向于继续深造，而志愿服务是他们最不常见的选择。此外研究生往往比本科生更倾向于选择兼职工作</strong></em></p><p>&#x3D;&gt; Overall, UK graduates and postgraduates were most likely to choose&#x2F;pursue further study&#x2F;education, while voluntary work was their least common choice. Besides, UK postgraduates were more inclined than graduates to work part-time</p><p>tend to do &#x3D; prefer to do &#x3D; be likely to do &#x3D; be inclined to do</p><h3 id="主体段"><a href="#主体段" class="headerlink" title="主体段"></a>主体段</h3><h4 id="常用句型"><a href="#常用句型" class="headerlink" title="常用句型"></a>常用句型</h4><h5 id="占比"><a href="#占比" class="headerlink" title="占比"></a>占比</h5><p><em><strong>百分比 + of + 分母</strong></em></p><p>例句：</p><ul><li><p><strong>工程师占这家科技公司员工的30%</strong></p><p>Engineers accounted for 30% of the staff at the tech company.</p></li><li><p><strong>这家科技公司30%的员工是工程师</strong></p><p>30% of the staff at technology company was engineers.</p></li><li><p><strong>工程师在这家科技公司员工中的占比是30%</strong></p><p>The percentage of engineers among staff at the technology company was 30%.</p></li></ul><h5 id="最高"><a href="#最高" class="headerlink" title="最高"></a>最高</h5><p><em><strong>指标+最高级</strong></em></p><p>例句：</p><ul><li><p><strong>在 1981 年至 1991 年期间，教师工资在学校总支出中所占的比例最高，该数值从 40% 上升到了 50%</strong></p><p>During 1981 and 1991, the proportion of teachers’ salaries in total school spending was the highest, with the figure increasing from 40% to 50%.</p></li><li><p><strong>在澳大利亚家庭能源消耗中，用于供暖的能源所占比例最高，达到了 42%</strong></p><p>The proportion of energy consumed by heating in Australian household energy use was the highest at 42%.</p><p>&#x3D;&#x3D; Heating accounted for 42% of Australia household energy use, which is the highest figure shown on the heat.</p></li></ul><p><em><strong>The figure for + 变量</strong></em></p><ul><li>By contract, the figure for cooling was the lowest at only 2%.</li></ul><h5 id="动态趋势"><a href="#动态趋势" class="headerlink" title="动态趋势"></a>动态趋势</h5><p><strong>上升</strong>：increase, rise, grow, climb(&#x3D;increase slightly), surge(&#x3D;increase dramatically)</p><p>例句：</p><ul><li><p><strong>社区回收的垃圾量在2019年增加到50吨，随后在2021年达到70吨</strong></p><p>The amount of garbage (which was) recycled by communities increased to 50 tons in2019, and then to 70 tons in 2021.</p></li></ul><p><strong>增长（超过）两倍</strong>：increased (over) twofold &#x2F; doubled<strong>三倍</strong>：threefold</p><p><strong>下降</strong>：decrease, drop, decline, dip(&#x3D;decrease slightly), plummet(&#x3D;decrease dramatically)</p><p><strong>波动</strong>：fluctuate around… &#x2F; fluctuate between … and …</p><p><strong>保持不变</strong>：remained unchanged &#x2F; stable, stay constant, leveled off</p><p><strong>达到峰值</strong>：reached its peak, at…</p><p><strong>trend</strong>：</p><p>例句：</p><p>​     The year 2017 saw an upward trend in the figures, increasing from 2 million per day in 2015 to 2.5 million per day in 2017.</p><p>&#x3D;&#x3D; There was an upward trend in the figures, increasing from 2 million per day in 2015 to 2.5 million per day in 2017.</p><p>&#x3D;&#x3D; An upward trend was seen in the figure, increasing from 2 million per day in 2015 to 2.5 million per day in 2017.</p><h3 id="范文"><a href="#范文" class="headerlink" title="范文"></a>范文</h3><p><em><strong>动态图：</strong></em></p><p>The chart illustrates the percentages of different categories of books sold by a book store in three different years.</p><p>In 1992, the proportion of adult fiction sold by the bookstore was the highest, with the figure increasing from 20% in 1992 to 35% in1992.</p><p>Similarly, and the figures for travel and children’s fiction also increased to 20 and 22%, respectively.</p><p>&#x3D;&#x3D; The year 1992 saw a similar increase in the figures for travel and children’s fiction, (up) to 20% and 22%, respectively.</p><p>&#x3D;&#x3D; In 1992, the book store also saw a similar increase in the figures for travel and children’s fiction, (up) to 20% and 22%, respectively.</p><p>&#x3D;&#x3D; There was a similar increase in the figures for travel and children’s fiction, (up) to 20% and 22%, respectively.</p><p>By contrast, the figures for biographies and “others” decrease to 5% and 18%, respectively.</p><p>The percentage of adult fiction was still the highest, with the figures increasing to 45% in 2012.</p><p>&#x3D;&#x3D; The figures for adult fiction reached its peak at 45%, which is the highest figure shown on the chart.</p><p>There was also an increase in the figures for children’s fiction and biographies, to 25% and 8%, respectively.</p><p>&#x3D;&#x3D; The year 2012 saw an increase in the figures for children’s fiction and biographies, to 25% and 8%, respectively.</p><p>By contrast, these was a different &#x2F; an opposite trend in the figures for travel and “others”, (down) to 10% and 12%, respectively.</p><p>&#x3D;&#x3D; By contrast, a different &#x2F; An opposite trend was seen in the figures for travel and “others”, (down) to 10% and 12%, respectively.</p><p>Overall, fiction became more and more popular &#x2F; gain more and more popularity among readers. Besides, in 1992 and 2012, Adult fiction was the best-selling types of books in 1992 and 2012.</p><p><em><strong>静态图：</strong></em></p><p>Water heating accounted for 30% of Australian household energy use, while the figure for refrigeration only stood at 7%.</p><p>&#x3D;&#x3D; Water heating accounted for 30% of Australian household energy use, <strong>followed by</strong> refrigeration at only 7%.</p><p>By comparison, the figures for lighting and cooling were much lower, at only 4% and 2% respectively.</p><p>&#x3D;&#x3D; By comparison, the figures for lighting and cooling were much lower, at no more than 5%.</p><p>Libraries are the most popular study spot in cities, with 30% of students choosing them, followed by cafes and parks, at 20% and 10% respectively.</p><p><em><strong>静态图&#x2F;饼图：</strong></em></p><p>The pie charts illustrate the average proportions of three types of nutrients (sodium, saturated fat, and added sugar) in typical meals consumed in the USA, all of which may be harmful to health if consumed <strong>excessively</strong>.</p><p>When it comes to sodium and saturated fat, dinner <strong>stands out as</strong> the meal with the highest average percentages. For sodium, dinner accounts for 43%, while lunch <strong>follows with</strong> 29%. Breakfast and snacks each <strong>contribute</strong> 14% to the sodium intake. Similarly, saturated fat also has the <strong>largest share</strong> in dinner, <strong>making up</strong> 37%. Lunch <strong>constitutes</strong> 26% of saturated fat consumption, while snacks (21%) and breakfast (16%) have relatively lower proportions.</p><p>In contrast, the distribution of added sugar differs significantly from that of sodium and saturated fat. Snacks are the primary source of added sugar, <strong>representing</strong> a <strong>substantial</strong> 42%. Dinner contributes 23%, lunch accounts for 19%, and breakfast has the smallest share at only 16%.</p><p>Overall, dinner is the main meal for sodium and saturated fat intake, whereas snacks are the most significant source of added sugar in typical American meals.</p><p><em><strong>静态图&#x2F;柱状图：</strong></em></p><p>The bar chart illustrates <strong>the coffee and tea buying and drinking habits of residents in</strong> Sydney, Melbourne, Brisbane, Adelaide and Hobart.</p><p><strong>Overall, it is notable that the data for</strong> going to a café for coffee or tea in the last four weeks <strong>exhibits significant fluctuations across</strong> cities, <strong>whereas figures for</strong> buying instant coffee <strong>demonstrate considerably greater stability</strong>. Café visits were highest in Melbourne and lowest in Adelaide, while purchasing fresh coffee remained the least common activity across all five cities. </p><p>As can be seen from the chart, visiting a café for coffee or tea was the most common activity in all five cities in the last four weeks, with the highest figure of 63% in Melbourne, followed by Hobart and Sydney. The lowest proportions were recorded in Brisbane (56%) and Adelaide (49%).</p><p>Buying instant coffee was the second most common habit. Hobart accounted for the highest proportion at 54%, while Sydney had the lowest at 46%. Regarding the purchase of fresh coffee in the last four weeks—the least common activity across all cities—the proportion was highest in Sydney at 43%, while Brisbane recorded the lowest figure at around 34%.</p><p><em><strong>动态图&#x2F;折线图</strong></em></p><p>The line graph illustrates the number of visitors who stayed on a particular Caribbean island over a period of seven years.</p><p>Overall, it is notable that the number of visitors staying on cruise ships exhibited significant fluctuations across the years, whereas the figures for those staying on the island remained considerably more stable.</p><p>As can be seen from the chart, the number of cruise ship visitors, which stood at approximately 0.3 million in 2010, dipped slightly to around 0.25 million in 2012 before rising steadily to peak at 2 million in 2017.</p><p>In contrast, the number of visitors staying on the island increased from 0.75 million in 2010 to 1.5 million in 2013, after which it levelled off and remained unchanged for the rest of the period.</p><p>Meanwhile, the total number of tourists rose from 1 million in 2010 to 3.5 million in 2017. Although this overall trend was upward, the growth was not consistent throughout the seven years — for example, there was little change between 2015 and 2016. </p><p><em><strong>动态图&#x2F;折线图</strong></em></p><p>The line graph illustrates the proportion of the population living in cities in the Philippines, Malaysia, Thailand and Indonesia over a 50-year period from 1970 to 2020, with projections up to 2040.</p><p>Overall, it is notable that the data for the Philippines exhibits significant fluctuations across the years, whereas figures for Thailand demonstrate considerably greater stability. Malaysia had the largest percentage of urban residents after 1990, while the Philippines had the lowest proportion at the beginning of the period, and Thailand became the lowest after 2000.</p><p>As can be seen from the chart, the proportion of Malaysia’s urban population <strong>shows a rapid upward trend</strong>, soaring from 30% in 1970 to around 82% in 2040. <strong>Similarly</strong>, Indonesia’s urban population increased significantly <strong>throughout the period</strong>, rising steadily from about 14% to 63% over the 70 years.</p><p>In contrast, the growth in the Philippines and Thailand was slower. Thailand’s figure rose consistently from 19% to 49%, without any decline. <strong>The Philippines, however, experienced fluctuations: it started at 31%, climbed to a peak of around 50% by 1990, dipped slightly in the early 2000s, and then recovered to reach 52% by 2040.</strong></p><h2 id="大作文"><a href="#大作文" class="headerlink" title="大作文"></a>大作文</h2><p>论文 40-45min 大于250词</p><p>优缺点、观点类、论述类、</p><p>报告类&#x2F;混合类</p><h3 id="审题-分段"><a href="#审题-分段" class="headerlink" title="审题&#x2F;分段"></a>审题&#x2F;分段</h3><p><strong>优缺点</strong> 利益分析 <em><strong>开头段+优点段+缺点段+结尾段</strong></em></p><p><strong>观点类</strong> 同意与否 <em><strong>开头段+支持段+反对段+结尾段</strong></em></p><p>​     <em><strong>开头段+支持段1+支持段2+结尾段</strong></em></p><p>​     <em><strong>开头段+反对段1+反对段2+结尾段</strong></em></p><p><strong>论述类</strong> 双边讨论 <em><strong>开头段+正方段+反方段+结尾段</strong></em></p><p><strong>报告类&#x2F;混合类</strong> 问题+策略&#x2F;问题+影响 <em><strong>开头段+原因段+方法段+结尾段</strong></em></p><p>​<em><strong>开头段+原因段+影响段+结尾段</strong></em></p><p>​<em><strong>开头段+影响段+方法段+结尾段</strong></em></p><h3 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h3><p><strong>A起因B经过C结果</strong></p><p>例：A：学习乐器B：提供了宝贵的技能和品质C：促进年轻人的发展</p><p>​A：线上问诊B：能够方便很多人看病，花费少&#x2F;缺乏精确诊断C：治愈小病&#x2F;耽误大病+产生恐慌</p><p>​A：科技进步B：增强抓捕烦人的能力&#x2F;被坏人利用C：犯罪率下降&#x2F;特定类型的犯罪率上升</p><p>​A：成年人自学&#x2F;报班B：有学习基础和动机&#x2F;</p><p>​A：社会竞争激烈B：忙于学业和事业C：很难抽出时间照顾养老人</p><p>​</p><h3 id="中心句"><a href="#中心句" class="headerlink" title="中心句"></a>中心句</h3><p>例：A：学习乐器B：提供了宝贵的技能和品质C：促进年轻人的发展</p><p>中心句：学习乐器可以促进年轻人的发展，因为它为年轻人提供了宝贵的技能和品质</p><p>​A：限制机动车进入市中心B：减少环境问题和交通堵塞C：让城市更加宜居</p><p>中心句：限制机动车进入市中心减少了环境问题和交通堵塞，因此城市更加宜居</p><p>Prohibiting vehicles from entering city centers alleviated air pollution and traffic congestion, and therefore enhanced urban livability.</p><p>​</p><p>​A：限行B：让长距离出行不太方便C：可能影响工作学习效率</p><p>中心句：因为限行让长距离出行不太方便，所以可能影响工作学习效率</p><p>Because this measure make it inconvenient to commute long distance, and therefore compromise work and study efficiency.</p><p>This measure might compromise work and study efficiency because long-distance commuting become inconvenient.</p><p>​A：为大公司工作B：稳定的收入和福利C：维持较高的生活标准</p><p>中心句：为大公司工作的人可以获得稳定的收入和福利，因此可以维持较高的生活标准</p><p>People working in major corporations can get stable income and comprehensive benefits packages, and therefore enjoy higher living standards.</p><p>People working in major corporations can get stable income and comprehensive benefits packages, thereby enjoying higher living standards.</p><p>​A：为大公司工作B：单调的工作任务C：较少发挥自己潜力的机会</p><p>中心句：为大公司工作会较少发挥自己潜力的机会，因为人们只处理单调的工作任务</p><p>Working for major corporations means a lot of routine tasks, thereby providing less chance to achieve personal potential</p><p>Working for major corporations provides less chance to achieve personal potential because people only deal with routine tasks there.</p><p>​A：使用信用卡B：过度消费C：造成经济负担</p><p>中心句：使用信用卡过度消费会造成经济负担</p><p>Using credit card misuse might lead to financial stain because of overconsumption</p><h3 id="解释句"><a href="#解释句" class="headerlink" title="解释句"></a>解释句</h3><p>例：A：学习乐器B：提供了宝贵的技能和品质C：促进年轻人的发展</p><p>A-B</p><p>缓解压力、持久专注、团队合作</p><p>B-C</p><p>提高收入、竞争优势、收获挑战</p><p>Telecommuting will reduce stress, because people no longer need to waste their valuable time travelling to and from work. They do not have to get up bed early in order to catch the early bus. Longer sleeping hours are helpful for conserving energy, thereby reducing the risk of getting&#x2F;contracting chronic diseases, such as diabetes and obesity. Working remotely also means more time for work. Once they complete their daily work, they can attend other activities to relax themselves.</p><p>The increasing use of technology in the workspace might help young people get jobs more easily, because they have greater ability, experience and mindset related to using technology.</p><p>学习能力强：因为身体仍然处于发育阶段，年轻人有着很高的neural plasticity神经可塑性，这意味着他们大脑的神经元neurons之间更加容易建立联系，这有益于学习新的概念和操作，比如使用人工智能助手检索信息从而完成代码编写或周报</p><p>Due to the fact that their bodies are still in the growing stage, young people have higher neural plasticity, which means that neurons in their brain can make connections with each other more easily. This is beneficial to learning new concepts and procedures, such as using AI assistants to search for information to write code or weekly reports.</p><p>此外，开放open-mindedness包容tolerance的品质qualities也让年轻人倾向于接触并熟悉更多科技相关的产品或者服务，比如使用智能手机上的社交媒体进行广告投放，这能够成为他们简历上的加分项，增加获得一份工作或者面试的机会</p><p>What’ s more, the qualities of open-mindedness and tolerance make young people prefer to explore and become familiar with more technology-related products and services, such as using the social media to advertise on mobile phones, which will be a plus on their resume, thereby increasing the chance of getting an interview or a job.</p><p>Due to the increasing use of technology in the work space, old people have more accessibility features to help them improve their efficiencies, so that they can get work more easily.</p><p>带屏幕的办公设备往往能够提供放大字体，从而让那些视力不好的老年人能够正常获取信息，从而像年轻人一样完成日常工作</p><p>另一个例子是，不擅长使用虚拟键盘进行文字输入的老年人能够轻松地切换成语音输入模式，从而与同事&#x2F;客户随时随地进行工作上的沟通</p><h3 id="词伙"><a href="#词伙" class="headerlink" title="词伙"></a>词伙</h3><h3 id="全文"><a href="#全文" class="headerlink" title="全文"></a>全文</h3><p>文化&#x2F;生活类<strong>Some people believe that it is best to accept a bad situation, such as an unsatisfactory job or shortage of money. Others argue that it is better to try and improve such situations.</strong></p><p><strong>Discuss both these views and give your own opinion.</strong></p><p>Our lives cannot always be free from difficult situations, such as an unsatisfying job or financial struggles. While some people believe it is best to accept these adverse circumstances, others argue that we should make efforts to improve them. In my view, trying to change bad situations is a wiser choice, as accepting them passively may lead to even worse outcomes.</p><p>Firstly, attempting to improve a bad situation helps us develop problem-solving skills and build resilience. For example, if someone is unhappy with their low-paying job, they can take online courses to learn new skills or spend time searching for better career opportunities. Although this process might be challenging—since changing a job often requires courage to step out of one’s comfort zone—it can eventually lead to a more satisfying career. In this way, facing difficulties actively not only solves immediate problems but also prepares us to handle future challenges with more confidence.</p><p>On the other hand, accepting a bad situation without trying to change it can have negative consequences. We can never be sure that the current situation is the worst it could be, so giving up easily might cause us to lose motivation in life. Take a student who fails an important exam: if they simply accept the poor grade and do nothing to improve, they may continue to struggle in subsequent tests and gradually lose interest in their studies.</p><p>Of course, there are times when accepting a situation is necessary, as it can bring a sense of peace. For instance, if a person cannot afford an expensive overseas holiday, they might choose to explore local parks or museums instead. This way, they can still enjoy a relaxed life without feeling stressed about money, which is beneficial for their mental health.</p><p>In conclusion, while accepting difficult situations can bring temporary peace, making efforts to improve them is generally better. It not only helps us solve problems effectively but also makes us stronger and more capable of dealing with life’s challenges in the long run.</p><p>环境类<strong>Some people say that the main environmental problem of our time is the loss of particular species of plants and animals. Others say that there are more important environmental problems.Discuss both these views and give your own opinion.</strong></p><p><strong>Give reasons for your answer and include any relevant examples from your own knowledge or experience.</strong></p><p>With the rapid development of human technology, environmental problems are becoming increasingly serious.<strong>(背景引入)</strong> There is a debate about whether the extinction of plants and animals is the most important environmental issue today, or if there are other more critical problems.<strong>(辩证话题)</strong> In my opinion, while other environmental challenges should also be taken seriously, the loss of species is the most significant because it has huge impacts on ecosystems and human beings.<strong>(自己观点)</strong></p><p>Firstly, the extinction of certain species greatly harms biodiversity, which is the foundation of stable ecosystems.<strong>(中心句1)</strong> Every living thing has a unique role in keeping the environment in balance.<strong>(解释句)</strong> For example, plants growing along rivers can stop soil from being washed away and filter pollutants, so they protect water quality.<strong>(举例解释)</strong> If these plants disappear, rivers might face serious sediment buildup and pollution, which would disrupt the homes of aquatic animals and reduce the clean water available for people.<strong>(假设没有)</strong> Also, many animals are key parts of food chains**(中心句2)<strong>: bees, for instance, help pollinate lots of plants</strong>(举例解释)<strong>, and without them, the growth of crops and wild plants would fail, putting food security at risk for both humans and other animals.</strong>(假设没有)** Such problems show that losing even one species can cause a chain reaction that damages whole ecosystems.<strong>(重申观点)</strong></p><p>Of course, other environmental issues like climate change, global warming, and rising sea levels are also critical because they directly threaten human survival. Global warming, for example, makes glaciers melt and extreme weather happen more often, which in turn destroys habitats and worsens the risk of species extinction. But this connection actually shows why species loss is so central: it is both a result of these bigger environmental crises and a reason for further ecological decline. Protecting species is <strong>not separate from</strong> solving other problems; <strong>instead, it is a basic step</strong> to make the natural world stronger, which is necessary for dealing with wider issues like climate change.</p><p>In conclusion, although no environmental problem can be overlooked, the loss of plant and animal species <strong>should be given top priority.</strong> <strong>(正反对比)</strong> Its effect on biodiversity supports the health of all ecosystems, and addressing it is essential for reducing other related environmental challenges.</p><p>文化&#x2F;生活类（同意与否）<strong>Some people say that music is a good way of bringing people of different cultures and ages together. To what extent do you agree or disagree with this opinion?</strong></p><p><strong>Give reasons for your answer and include any relevant examples from your own knowledge or experience.</strong></p><p>With the rapid development of human social civilization, we have more opportunities to communicate with people in different countries and ages by the convenient network and developed transport. However, whether music gathers people of all ages and cultures <strong>has sparked widespread debate.</strong> In my point of view, music seems to have magic <strong>that</strong> can unite people although they come from diverse regions and age groups.</p><p>Firstly, music is the earliest artistic form to express our <strong>feelings</strong>, which can be understood by most people easily. Everyone will share the same <strong>feelings</strong> when they hear the same songs, no matter where they come from or how old they are. For example, both Chinese and Western <strong>listeners</strong>, after hearing the famous song called <strong>“Moon Reflected on Two Lakes”</strong> played on <strong>erhu, a traditional Chinese instrument</strong>, can <strong>feel</strong> the <strong>melancholy</strong> and sadness in it — <strong>not because they understand Chinese culture, but because humans naturally feel sadness when they hear slow, soft music — and music shows these feelings in a way that needs no words.</strong> If people can <strong>share</strong> the same mood, that is a way to <strong>bring</strong> people together.</p><p><strong>Beyond emotional expression,</strong> music is also extremely popular all around the world with just certain categories, and therefore <strong>a large number of</strong> people share the same love. Thanks to it, music <strong>becomes</strong> a platform and a <strong>common</strong> topic for those who have the same interest to communicate together <strong>in a friendly way</strong>. So, there is no doubt that music is a useful tool for human solidarity. </p><p><strong>Admittedly,</strong> there are some particular <strong>types of</strong> music with strong cultural roots which <strong>are</strong> hard to be accessed by <strong>outsiders</strong>, such as <strong>religious music</strong> and traditional operas. For instance, <strong>Peking Opera is</strong> favored by less and less teenagers, so that they will have a generation gap <strong>with</strong> the old. </p><p>In conclusion, while some types of music may be unpopular, the contributions music <strong>brings</strong> to narrowing the gap among people should not be ignored. That is absolutely a good way of bringing people of different cultures and ages together. </p><p>社会类<strong>Some people think that competition at work,at school and in daily life is a good thing. Others believe that we should try to cooperate more,rather than competing against each other.</strong></p><p><strong>Discuss both these views and give your own opinion.</strong></p><p>返璞归真，易学习，速写</p><p>Nowadays, there are different opinions about competition and cooperation. While some people believe it is best to compete with your classmates or colleagues, others argue that we should cooperate more. In my view, trying to cooperate is a wiser choice, as competing too often may lead to a worse social situation.</p><p>First, cooperation helps people finish harder tasks. Many jobs are too difficult for one person to do alone. When people work together, they can share ideas and skills, so the task becomes easier. For example, in school, when we have a group project, each student has different strengths. Some are good at drawing, some at writing, and some at speaking. If we cooperate, we can make a better project than if we work alone.</p><p>Second, cooperation makes people’s relationships better. When people cooperate, they help each other and stay friendly. But competition can make people fight or feel negative about each other. For instance, in a basketball game, team members cooperate to win. They pass the ball, support each other, and even if they lose, they still remain friends. But if two people only compete to be the “best player”, they might argue and stop talking to each other.</p><p>Admittedly, competition can be good sometimes. It can make people work harder and show their best. For example, in a math test, students might study more because they want a higher score than others. However, too much competition can make people feel stressed and unhappy. They might start to dislike others just to win, which harms friendships and teamwork.</p><p>In conclusion, I think cooperation is a better choice than competition. It helps us finish difficult tasks and build good relationships. While competition has some benefits, cooperation makes life better in the long run.</p><h2 id="好用"><a href="#好用" class="headerlink" title="好用"></a>好用</h2><p><strong>让步段可用</strong></p><blockquote><p>while both views have merit 尽管双方都有道理 </p><p>come at the cost of 以…为代价</p><p>still far from enough to</p></blockquote><p>buy、spend money &#x3D; invest in 投资</p><p>solve &#x3D; address</p><p>take priority over 比…优先</p><p>change &#x3D; transform</p><p>From this angle 从这个角度来说</p><p>improve &#x3D; promote &#x3D; advance</p><p>task &#x3D; mission &#x3D; assignment</p><p>explain &#x3D; justify</p><p>need &#x3D; demand</p><p>give &#x3D; expand access to</p><p>underdeveloped region 欠发达地区</p><p>very good &#x3D; worthwhile</p><p>think &#x3D; believe</p><p>best &#x3D; most effective &#x3D; useful</p><p>understand &#x3D; insight 洞察</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>The diagram illustrates how to make sugar from sugar cane.</p><p>It is noticeable that there are seven <strong>distinct stages</strong> in the manufacturing process for making sugar from sugar cane. <strong>These mainly include</strong> growing and harvesting sugar canes, purifying and evaporating juice, and drying and cooling sugar crystals.</p><p><strong>At the first stage in the process,</strong> sugar canes are planted, and it takes 12 to 18 months to grow. <strong>Next</strong>, these sugar canes are harvested either by machines or farmers to be prepared for further manufacturing.</p><p><strong>At the third step shown on the diagram,</strong> the sugar canes are crushed by a big crusher to produce juice. <strong>Then</strong>, a limestone filter is used to purify the sugar cane juice which is subsequently delivered into a big evaporator. In this evaporator, the juice is heated to be turned into syrup which is more condensed. <strong>At stage six,</strong> a machine called “Centrifuge” is utilized to separate sugar crystals from the syrup. These sugar crystals are then dried and cooled in a big container, and sugar is finally produced.</p><p>The diagram shows how ethanol, a type of biofuel, is made from plants. Overall, there are seven main steps: growing plants, harvesting them, preparing the plant material, getting cellulose, turning it into sugar, adding microbes to make ethanol, and finally using it in vehicles — which releases carbon dioxide back into the air for new plants to use.</p><p>In the first step, trees and other plants grow by using energy from sunlight and carbon dioxide from the air. When they are ready, machines collect them so they can be used in the next stage.</p><p>In the third step, the collected plants are put into large machines to get cellulose out. After that, chemicals are used to turn the cellulose into simple sugars. Then, microbes are added to these sugars, and through a natural process, ethanol is produced.</p><p>This ethanol is then used as fuel in many kinds of vehicles — like cars, trucks, and even airplanes. When the fuel is burned, it releases carbon dioxide. This CO₂ goes back into the environment, where new plants take it in to grow again — completing the cycle.</p><p>​</p><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><p>The maps illustrate some changes that were made to a city hospital’s transport <strong>infrastructure</strong> between the years 2007 and 2010.</p><p>It is noticeable that three main <strong>modifications</strong> were made to the hospital’s vehicle access. <strong>These involved</strong> the building of a new bus station, new roundabouts and new parking facilities.</p><p><strong>Looking at the changes in more detail,</strong> we can see that in 2007 there were three bus stops on either side of Hospital Road. These were no longer present in 2010, <strong>and instead</strong> we see the <strong>addition</strong> of a bus station on the west side of Hospital Road. This bus station <strong>is accessed via</strong> two new roundabouts; the first roundabout is at the <strong>intersection</strong> of City Road and Hospital Road, while the second is at the other end of Hospital Road, at the <strong>junction</strong> with the hospital ring road.</p><p>The two maps also show that changes were made to public and staff parking areas. In 2007, staff and visitors used the same car park, <strong>which was situated to</strong> the east of Hospital Road and accessed via the ring road. <strong>However, by</strong> 2010 this original car park had become a designated area for staff parking only. A new car park located on the east side of the ring road, provided parking for members of the public.</p><p>词汇短语：infrastructure 基础设施</p><p>​modifications 改变</p><p>​addition 增加物</p><p>​be accessed via 从…通过</p><p>​intersection 十字路口junction 交汇点</p>]]></content>
      
      
      <categories>
          
          <category> 雅思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雅思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+Github搭建个人图床</title>
      <link href="/2025/07/27/pigco/"/>
      <url>/2025/07/27/pigco/</url>
      
        <content type="html"><![CDATA[<h1 id="PicGo-Github搭建个人图床"><a href="#PicGo-Github搭建个人图床" class="headerlink" title="PicGo+Github搭建个人图床"></a>PicGo+Github搭建个人图床</h1><h2 id="下载安装PicGo"><a href="#下载安装PicGo" class="headerlink" title="下载安装PicGo"></a>下载安装PicGo</h2><p>首先我们到github搜索picgo，这里附上网址<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p>点开Releases下载符合自己系统的版本</p><div style="text-align: center;">   <img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B1.png" alt="image-20250727125600266" style="zoom: 40%;" /> </div><div style="text-align: center;">   <img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B2.png" alt="image-20250727125847630" style="zoom:50%;" /> </div><p>下载之后根据提示进行安装，安装完成运行程序，或许会发现没有窗口显示，当时我以为文件损坏了，又是重新下载又是检查配置文件检查日志的，后来发现它在这</p><div style="text-align: center;">   <img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B3.png" alt="image-20250727130216773" style="zoom:50%;" /> </div><p>一点就打开了。</p><h2 id="配置picgo"><a href="#配置picgo" class="headerlink" title="配置picgo"></a>配置picgo</h2><p>打开picgo设置，选择自己需要的图床，这里以github为例</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B4.png" alt="image-20250727131905576" style="zoom:50%;" /><p>之后点开图床设置，能找到github，点开</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/pigco%E6%95%99%E7%A8%8B5.png" alt="image-20250727132653416" style="zoom:50%;" /><p>这里需要填一些设置</p><ol><li><p>首先是仓库名，需要我们到github重新创建一个仓库，<strong>一定得是public</strong>，名字随意，然后复制完整的仓库名，即“id&#x2F;仓库名”</p></li><li><p>然后是分支名填main即可</p></li><li><p>存储路径就是在github中存到哪个文件夹，我们就写”img&#x2F;“即可</p></li><li><p>最后一个框是cdn链接，就写上<a href="https://cdn.jsdelivr.net/gh/+%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/+仓库名</a></p></li></ol><p>关于Token我们需要去github上生成</p><p>打开GitHub -&gt; 点击头像 -&gt; settings -&gt; 划到最底下找到Developer Settings -&gt; 找到tokens，生成新token（classic）</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B7.png" alt="image-20250727134023692" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B8.png" alt="image-20250727134511260" style="zoom:50%;" /><p><strong>注意生成的Token只会在创建的时候展示一次，请保存好</strong>，复制token填入picgo中即可，点击设为默认图床。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>如果是平时想上传图片到github上的话，只需要在picgo主页选择上传的方式即可</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B9.png" alt="image-20250727135250247" style="zoom:50%;" /><p>如果是想在写markdown文件的时候插入图片的话，这里以Typora做演示</p><p>打开偏好设置 -&gt; 选择图像 -&gt; 找到上传服务，选择PicGo(app) -&gt; PicGo路径选择下载picgo的目录</p><p>之后可以验证图片上传选项</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B10.png" alt="image-20250727135502092" style="zoom:50%;" /><p>在写文章的时候，如果需要插入图片，直接右键插入图像，或者是截图复制粘贴进来，插入之后会发现显示的仍是本地的路径，我们需要点击”上传图片“来上传到github上，之后就会变成一张网络图片了</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B11.png" alt="image-20250727140037182" style="zoom:50%;" /><p>大功告成！</p><h2 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h2><p>在搭建的过程中遇到过一些问题</p><ol><li>Typora在验证图片上传选项时出现错误，因为需要picgo上设置里找到设置Server，监听端口需要和Typora一致36677（默认）</li></ol><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B12.png" alt="image-20250727140609601" style="zoom:50%;" /><ol start="2"><li><p>picgo上传图片时显示上传失败，请检查配置项和网络，在网上搜索了一圈也解决不了，有说把Server关了再开的，有说这说那的，我的报错日志是Error: connect ECONNREFUSED 127.0.0.1:443，最后是在picgo的设置里，找到代理和镜像，上传代理写上<a href="https://127.0.0.1:7890，毕竟github在大陆访问还是不太稳定">https://127.0.0.1:7890，毕竟github在大陆访问还是不太稳定</a></p></li><li><p>还有一种报错也是显示上传失败，请检查配置项和网络，可能是你上传图片的时候上传了两张命名一样的图片</p><img src="https://cdn.jsdelivr.net/gh/hslslsl/picgo/img/picgo%E6%95%99%E7%A8%8B13.png" alt="image-20250727141244461" style="zoom:50%;" /><p>或许以上的办法都没法帮你解决问题，最好的办法就是查看日志啦，日志文件在C:\Users\用户名\AppData\Roaming\picgo\里，那个picgo.log就是啦。</p><p>到此结束，over。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picgo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2025/07/26/hello-world/"/>
      <url>/2025/07/26/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="学海无涯，愿留微痕"><a href="#学海无涯，愿留微痕" class="headerlink" title="学海无涯，愿留微痕"></a>学海无涯，愿留微痕</h1><hr><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>本人是一名来自深圳的软件工程专业的学生，并无过多可介绍。常言”人贵自知”，然审视己身，爱好虽广，却皆如蜻蜓点水，浅尝辄止，涉猎的多了每种都只能称”入门”。</p><hr><h2 id="为什么写博客"><a href="#为什么写博客" class="headerlink" title="为什么写博客"></a>为什么写博客</h2><ul><li><p><strong>其一</strong>，实有几分功利之念萦怀，作为软件工程专业的学生，主修就是Java，而”Java已死”之类的论调不绝于耳，无论其真实性如何，都让我意识到在技术洪流中，仅仅掌握课堂知识可能并不足够，或许是为了提高自己的竞争力，我想开始写博客来包装自己，希望终能汇成证明自己价值的篇章。</p></li><li><p><strong>其二</strong>，亦是更深层的叩问，源于内心久积的空茫。转眼大学时光已过大半，校园学习生涯似乎接近尾声。回首过去十余年的”苦读”，竟发现自己留下的几乎只有为了应试而堆积的、厚重的笔记本，不为爱好而学。那些真正因兴趣而生的灵光一闪、解决问题的豁然开朗、探索未知的兴奋悸动，仿佛都消散在了时间里。这让我感到一种难以言喻的空白。大学的自由也有学业自由，我可以凭着自己的好奇心，去学任何想学的东西，而不仅仅是为了分数。写博客，或许就是一个契机。它不仅能见证我的成长，更能帮我找回学习本身那种纯粹。</p></li></ul><hr><h2 id="博客会写些什么"><a href="#博客会写些什么" class="headerlink" title="博客会写些什么"></a>博客会写些什么</h2><p>当然就是自己学习的记录，或者是遇到的问题的解决方法，可能还会被我拿来当作代码仓库，以后想用就翻出来。</p><p>虽然专业中写的最多的就是Java，但我实在是喜欢不上Java，哪怕它很优秀也很强大。或许是被网络上的舆论所影响了，我已经在考虑转型。前几年风风火火的Web3.0和区块链现在已经有所沉寂，在发展中确实方方面面都受到限制，但我依旧有研究区块链的兴趣，研究它，对我而言并非追逐风口，更像是对一种可能性的好奇与押注。与其在犹豫中观望，不如躬身入局。所以接下来我会先从最基础的Solidity开始学起并同步开始写博客，希望自己能坚持下来。</p><hr><h2 id="写在开始之际"><a href="#写在开始之际" class="headerlink" title="写在开始之际"></a>写在开始之际</h2><p>写这第一篇博客，像在空白的画布上落下第一笔。自知文笔稚拙，思虑或显浅薄。但重要的不是完美，而是开始，是行动，是留下属于自己思考与成长的痕迹，而非让它们在记忆中无声湮灭。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
